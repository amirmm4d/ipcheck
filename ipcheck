#!/usr/bin/env bash
#
# ipcheck - Advanced, parallel IP reputation checker v2.1.6

set -euo pipefail

# Version
IPCHECK_VERSION="2.1.6"

if [[ -t 1 ]]; then
    GREEN=$(tput setaf 2)
    RED=$(tput setaf 1)
    YELLOW=$(tput setaf 3)
    BLUE=$(tput setaf 4)
    NC=$(tput sgr0) # No Color
else
    GREEN="" RED="" YELLOW="" BLUE="" NC=""
fi

STATUS_DIR=$(mktemp -d)
trap 'rm -rf -- "$STATUS_DIR"' EXIT

# Global variables for options
LOG_DIR=""
LOG_FORMAT="txt"  # txt or json
ASK_VPN_INSTALL=false  # Ask interactively after server check
AUTO_VPN_TYPE=""       # Auto-install VPN type (singbox, xray, v2ray, shadowsocks, openvpn, cisco)
ENABLE_SCORING=false
ENABLE_CDN_CHECK=false
ENABLE_ROUTING_CHECK=false
ENABLE_PORT_SCAN=false
ENABLE_REALITY_TEST=false
ENABLE_USAGE_HISTORY=false
ENABLE_SUGGESTIONS=false

# Results storage for scoring and reports
declare -A SCORE_METRICS
declare -A CDN_RESULTS
declare -A ROUTING_RESULTS
declare -A PORT_RESULTS
declare -A REALITY_RESULTS
declare -A USAGE_RESULTS

# --- Core Functions ---

load_config() {
    local config_file="$HOME/.config/ipcheck/keys.conf"
    if [[ -f "$config_file" ]]; then
        # Validate config file permissions (should be 600)
        local perms
        perms=$(stat -c "%a" "$config_file" 2>/dev/null || stat -f "%OLp" "$config_file" 2>/dev/null || echo "644")
        if [[ "$perms" != "600" ]] && [[ "$perms" != "0600" ]]; then
            log_message "WARNING: Config file permissions are $perms, should be 600"
        fi
        set -o allexport
        # shellcheck source=/dev/null
        source "$config_file"
        set +o allexport
    fi
}

write_status() {
    local ip_dir="$1" check_name="$2" status="$3" details="$4"
    local status_code
    case "$status" in
    "${GREEN}PASSED"*) status_code=0 ;;
    "${RED}FAILED"*) status_code=1 ;;
    "${YELLOW}SKIPPED"*) status_code=2 ;;
    *) status_code=3 ;; # ERROR
    esac
    echo "$status_code|$status|$details" >"$ip_dir/$check_name"
}

spinner() {
    local pid=$1 delay=0.1 spinstr='|/-\'
    while ps -p "$pid" >/dev/null; do
        local temp=${spinstr#?}
        printf " [%c]  " "$spinstr"
        local spinstr=$temp${spinstr%"$temp"}
        sleep $delay
        printf "\r"
    done
    printf "    \r"
}

get_server_ip() {
    curl -s --max-time 10 https://api.ipify.org || curl -s --max-time 10 https://ifconfig.me || echo ""
}

# --- Logging Functions ---

log_message() {
    local level="${2:-INFO}"
    local message="$1"
    local timestamp
    timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    
    if [[ -z "$LOG_DIR" ]]; then
        return
    fi
    
    # Ensure log directory exists
    mkdir -p "$LOG_DIR"
    
    # Rotate logs if needed (keep last 30 days, max 100MB per file)
    rotate_logs
    
    local log_file="$LOG_DIR/ipcheck-$(date +%Y%m%d).log"
    
    if [[ "$LOG_FORMAT" == "json" ]]; then
        local log_entry
        log_entry=$(jq -n \
            --arg timestamp "$timestamp" \
            --arg level "$level" \
            --arg message "$message" \
            '{timestamp: $timestamp, level: $level, message: $message}')
        echo "$log_entry" >>"$log_file"
    else
        echo "[$timestamp] [$level] $message" >>"$log_file"
    fi
}

rotate_logs() {
    if [[ ! -d "$LOG_DIR" ]]; then
        return
    fi
    
    # Remove logs older than 30 days
    find "$LOG_DIR" -name "ipcheck-*.log" -type f -mtime +30 -delete 2>/dev/null || true
    
    # Check file size and rotate if > 100MB
    local log_file="$LOG_DIR/ipcheck-$(date +%Y%m%d).log"
    if [[ -f "$log_file" ]]; then
        local size
        size=$(stat -f%z "$log_file" 2>/dev/null || stat -c%s "$log_file" 2>/dev/null || echo "0")
        if [[ $size -gt 104857600 ]]; then  # 100MB
            mv "$log_file" "${log_file}.$(date +%H%M%S)"
        fi
    fi
}

# --- Check Functions ---

check_ipqs() {
    local ip="$1" ip_dir="$2"
    log_message "Checking IPQualityScore for $ip"
    if [[ -z "${IPQS_KEY:-}" ]]; then
        write_status "$ip_dir" "IPQualityScore" "${YELLOW}SKIPPED" "API key not set"
        log_message "IPQualityScore skipped for $ip: API key not set"
        return
    fi
    local resp
    resp=$(curl --max-time 15 -sf "https://ipqualityscore.com/api/json/ip/$IPQS_KEY/$ip" || true)
    if [[ -z "$resp" ]]; then
        write_status "$ip_dir" "IPQualityScore" "${RED}ERROR" "Request failed"
        log_message "IPQualityScore error for $ip: Request failed"
        return
    fi
    # Save raw API response
    echo "$resp" | jq . > "$ip_dir/raw_ipqs.json" 2>/dev/null || echo "$resp" > "$ip_dir/raw_ipqs.json"
    log_message "IPQualityScore response for $ip: $resp"
    local score proxy
    score=$(jq -r '.fraud_score // "unknown"' <<<"$resp")
    proxy=$(jq -r '.proxy // "false"' <<<"$resp")
    local details="Fraud Score: $score, Proxy: $proxy"
    if [[ "$proxy" == "true" || "$score" =~ ^[0-9]+$ ]] && [[ "$score" -gt 75 ]]; then
        write_status "$ip_dir" "IPQualityScore" "${RED}FAILED" "$details"
        log_message "IPQualityScore FAILED for $ip: $details"
    else
        write_status "$ip_dir" "IPQualityScore" "${GREEN}PASSED" "$details"
        log_message "IPQualityScore PASSED for $ip: $details"
    fi
}

check_abuseipdb() {
    local ip="$1" ip_dir="$2"
    log_message "Checking AbuseIPDB for $ip"
    if [[ -z "${ABUSEIPDB_KEY:-}" ]]; then
        write_status "$ip_dir" "AbuseIPDB" "${YELLOW}SKIPPED" "API key not set"
        log_message "AbuseIPDB skipped for $ip: API key not set"
        return
    fi
    local resp
    resp=$(curl --max-time 15 -sf -X POST \
        -H "Key: $ABUSEIPDB_KEY" \
        -H "Accept: application/json" \
        -d "ipAddress=$ip&maxAgeInDays=90&verbose" \
        "https://api.abuseipdb.com/api/v2/check" || true)
    if [[ -z "$resp" ]]; then
        write_status "$ip_dir" "AbuseIPDB" "${RED}ERROR" "Request failed"
        log_message "AbuseIPDB error for $ip: Request failed"
        return
    fi
    # Save raw API response
    echo "$resp" | jq . > "$ip_dir/raw_abuseipdb.json" 2>/dev/null || echo "$resp" > "$ip_dir/raw_abuseipdb.json"
    log_message "AbuseIPDB response for $ip: $resp"
    local confidence
    confidence=$(jq -r '.data.abuseConfidenceScore // "unknown"' <<<"$resp")
    local usage_type
    usage_type=$(jq -r '.data.usageType // "unknown"' <<<"$resp")
    local details="Confidence: $confidence%, Type: $usage_type"
    if [[ "$confidence" =~ ^[0-9]+$ ]] && [[ "$confidence" -ge 25 ]]; then
        write_status "$ip_dir" "AbuseIPDB" "${RED}FAILED" "$details"
        log_message "AbuseIPDB FAILED for $ip: $details"
    else
        write_status "$ip_dir" "AbuseIPDB" "${GREEN}PASSED" "$details"
        log_message "AbuseIPDB PASSED for $ip: $details"
    fi
}

check_scamalytics() {
    local ip="$1" ip_dir="$2"
    log_message "Checking Scamalytics for $ip"
    local resp
    resp=$(curl --max-time 15 -sf "https://scamalytics.com/api/v1/ip/$ip" || true)
    if [[ -z "$resp" ]]; then
        write_status "$ip_dir" "Scamalytics" "${RED}ERROR" "Request failed"
        log_message "Scamalytics error for $ip: Request failed"
        return
    fi
    # Save raw API response
    echo "$resp" | jq . > "$ip_dir/raw_scamalytics.json" 2>/dev/null || echo "$resp" > "$ip_dir/raw_scamalytics.json"
    log_message "Scamalytics response for $ip: $resp"
    local risk_score
    risk_score=$(jq -r '.risk_score // "unknown"' <<<"$resp" 2>/dev/null || echo "unknown")
    local details="Risk Score: $risk_score"
    if [[ "$risk_score" =~ ^[0-9]+$ ]] && [[ "$risk_score" -ge 50 ]]; then
        write_status "$ip_dir" "Scamalytics" "${RED}FAILED" "$details"
        log_message "Scamalytics FAILED for $ip: $details"
    else
        write_status "$ip_dir" "Scamalytics" "${GREEN}PASSED" "$details"
        log_message "Scamalytics PASSED for $ip: $details"
    fi
}

check_ripe() {
    local ip="$1" ip_dir="$2"
    log_message "Checking RIPE Atlas for $ip"
    if [[ -z "${RIPE_KEY:-}" ]]; then
        write_status "$ip_dir" "RIPE_Atlas" "${YELLOW}SKIPPED" "API key not set"
        log_message "RIPE Atlas skipped for $ip: API key not set"
        return
    fi
    # Check if we can get Iran probes and test connectivity
    local resp
    resp=$(curl --max-time 15 -sf -H "Authorization: Key $RIPE_KEY" \
        "https://atlas.ripe.net/api/v2/probes/?country_code=IR&status=1&limit=5" || true)
    if [[ -z "$resp" ]]; then
        write_status "$ip_dir" "RIPE_Atlas" "${RED}ERROR" "Request failed"
        log_message "RIPE Atlas error for $ip: Request failed"
        return
    fi
    local probe_count
    probe_count=$(jq -r '.count // 0' <<<"$resp")
    local details="Iran probes available: $probe_count"
    if [[ "$probe_count" -gt 0 ]]; then
        write_status "$ip_dir" "RIPE_Atlas" "${GREEN}PASSED" "$details"
        log_message "RIPE Atlas PASSED for $ip: $details"
    else
        write_status "$ip_dir" "RIPE_Atlas" "${YELLOW}SKIPPED" "No Iran probes available"
        log_message "RIPE Atlas skipped for $ip: No Iran probes available"
    fi
}

check_host() {
    local ip="$1" ip_dir="$2"
    log_message "Checking Check-Host for $ip"
    local resp
    resp=$(curl --max-time 15 -sf "https://check-host.net/check-ping?host=$ip&max_nodes=5" || true)
    if [[ -z "$resp" ]]; then
        write_status "$ip_dir" "Check-Host" "${RED}ERROR" "Request failed"
        log_message "Check-Host error for $ip: Request failed"
        return
    fi
    log_message "Check-Host response for $ip: $resp"
    # Parse result URL and check status
    local result_url
    result_url=$(jq -r '.request_id // empty' <<<"$resp")
    if [[ -z "$result_url" ]]; then
        write_status "$ip_dir" "Check-Host" "${RED}ERROR" "Invalid response"
        log_message "Check-Host error for $ip: Invalid response"
        return
    fi
    sleep 2 # Wait for check to complete
    local result
    result=$(curl --max-time 15 -sf "https://check-host.net/check-result/$result_url" || true)
    local success_count=0
    if [[ -n "$result" ]]; then
        success_count=$(echo "$result" | jq -r '[.[] | select(. != null) | .[] | select(. != null) | .[0] // empty] | length' 2>/dev/null || echo "0")
    fi
    local details="Successful pings: $success_count/5"
    if [[ "$success_count" -ge 3 ]]; then
        write_status "$ip_dir" "Check-Host" "${GREEN}PASSED" "$details"
        log_message "Check-Host PASSED for $ip: $details"
    else
        write_status "$ip_dir" "Check-Host" "${RED}FAILED" "$details"
        log_message "Check-Host FAILED for $ip: $details"
    fi
}

check_hosttracker() {
    local ip="$1" ip_dir="$2"
    log_message "Checking HostTracker for $ip"
    if [[ -z "${HT_KEY:-}" ]]; then
        write_status "$ip_dir" "HostTracker" "${YELLOW}SKIPPED" "API key not set"
        log_message "HostTracker skipped for $ip: API key not set"
        return
    fi
    # HostTracker API endpoint unknown - placeholder implementation
    write_status "$ip_dir" "HostTracker" "${YELLOW}SKIPPED" "API endpoint not available"
    log_message "HostTracker skipped for $ip: API endpoint not available"
}

# --- New API Check Functions ---

check_ipapi() {
    local ip="$1" ip_dir="$2"
    log_message "Checking ipapi.co for $ip"
    local resp
    resp=$(curl --max-time 15 -sf "https://ipapi.co/$ip/json/" || true)
    if [[ -z "$resp" ]]; then
        write_status "$ip_dir" "ipapi" "${RED}ERROR" "Request failed"
        log_message "ipapi error for $ip: Request failed"
        return
    fi
    # Save raw API response
    echo "$resp" | jq . > "$ip_dir/raw_ipapi.json" 2>/dev/null || echo "$resp" > "$ip_dir/raw_ipapi.json"
    log_message "ipapi response for $ip: $resp"
    local org asn
    org=$(jq -r '.org // "unknown"' <<<"$resp")
    asn=$(jq -r '.asn // "unknown"' <<<"$resp")
    local details="ASN: $asn, Org: $org"
    # Store for scoring
    SCORE_METRICS["${ip}_asn"]="$asn"
    SCORE_METRICS["${ip}_org"]="$org"
    SCORE_METRICS["${ip}_is_datacenter"]=$(jq -r '.org // ""' <<<"$resp" | grep -qiE "(datacenter|hosting|cloud|server)" && echo "true" || echo "false")
    write_status "$ip_dir" "ipapi" "${GREEN}PASSED" "$details"
    log_message "ipapi PASSED for $ip: $details"
}

check_ipregistry() {
    local ip="$1" ip_dir="$2"
    log_message "Checking ipregistry.io for $ip"
    local api_key="${IPREGISTRY_KEY:-}"
    local url
    if [[ -n "$api_key" ]]; then
        url="https://api.ipregistry.co/$ip?key=$api_key"
    else
        url="https://api.ipregistry.co/$ip"
    fi
    local resp
    resp=$(curl --max-time 15 -sf "$url" || true)
    if [[ -z "$resp" ]]; then
        write_status "$ip_dir" "ipregistry" "${RED}ERROR" "Request failed"
        log_message "ipregistry error for $ip: Request failed"
        return
    fi
    # Save raw API response
    echo "$resp" | jq . > "$ip_dir/raw_ipregistry.json" 2>/dev/null || echo "$resp" > "$ip_dir/raw_ipregistry.json"
    log_message "ipregistry response for $ip: $resp"
    local company
    company=$(jq -r '.company.name // "unknown"' <<<"$resp")
    local details="Company: $company"
    SCORE_METRICS["${ip}_company"]="$company"
    write_status "$ip_dir" "ipregistry" "${GREEN}PASSED" "$details"
    log_message "ipregistry PASSED for $ip: $details"
}

check_spamhaus() {
    local ip="$1" ip_dir="$2"
    log_message "Checking Spamhaus for $ip" "INFO"
    # Spamhaus DNSBL check (no API key needed for basic check)
    local reversed_ip
    reversed_ip=$(echo "$ip" | awk -F. '{print $4"."$3"."$2"."$1}')
    local result
    result=$(dig +short "${reversed_ip}.zen.spamhaus.org" 2>/dev/null || echo "")
    local details="Not listed"
    local abuse_count=0
    if [[ -n "$result" ]]; then
        # Parse Spamhaus response codes
        local code
        code=$(echo "$result" | awk '{print $1}')
        case "$code" in
            127.0.0.2) details="SBL - Spamhaus SBL Listed" ; abuse_count=50 ;;
            127.0.0.3) details="SBL - Spamhaus CSS Listed" ; abuse_count=40 ;;
            127.0.0.4) details="XBL - CBL Listed" ; abuse_count=45 ;;
            127.0.0.5) details="XBL - Spamhaus DROP/EDROP Listed" ; abuse_count=60 ;;
            127.0.0.6) details="XBL - Spamhaus DROP Listed" ; abuse_count=55 ;;
            127.0.0.7) details="XBL - Spamhaus EDROP Listed" ; abuse_count=50 ;;
            *) details="Listed in Spamhaus: $result" ; abuse_count=30 ;;
        esac
        write_status "$ip_dir" "Spamhaus" "${RED}FAILED" "$details"
        log_message "Spamhaus FAILED for $ip: $details" "WARN"
        SCORE_METRICS["${ip}_spamhaus_listed"]="true"
        SCORE_METRICS["${ip}_abuse_90d"]="$abuse_count"
    else
        write_status "$ip_dir" "Spamhaus" "${GREEN}PASSED" "$details"
        log_message "Spamhaus PASSED for $ip: $details" "INFO"
        SCORE_METRICS["${ip}_spamhaus_listed"]="false"
    fi
}

# Generate comprehensive abuse report
generate_abuse_report() {
    local ip="$1" ip_dir="$2"
    local abuse_json
    abuse_json=$(jq -n \
        --arg ip "$ip" \
        --arg spamhaus "${SCORE_METRICS["${ip}_spamhaus_listed"]:-false}" \
        --arg abuse_count "${SCORE_METRICS["${ip}_abuse_90d"]:-0}" \
        '{
            ip: $ip,
            spamhaus_listed: ($spamhaus == "true"),
            abuse_count_90d: ($abuse_count | tonumber),
            confidence_score: (if ($spamhaus == "true") then 75 else 0 end)
        }')
    echo "$abuse_json" > "$ip_dir/abuse_report.json"
    log_message "Generated abuse report for $ip" "INFO"
}

# --- Scoring Engine ---

calculate_clean_score() {
    local ip="$1"
    local total_score=100.0
    local weights=(
        "fraud_score:0.30"
        "proxy_score:0.20"
        "vpn_score:0.15"
        "abuse_reports:0.20"
        "bot_activity:0.10"
        "datacenter:0.05"
    )
    
    # Extract metrics from check results
    local fraud_score=0
    local proxy_score=0
    local vpn_score=0
    local abuse_reports=0
    local bot_activity=0
    local is_datacenter=0
    
    # Get IPQS data if available
    local ip_dir="$STATUS_DIR/$(echo "$ip" | tr '.' '_')"
    if [[ -f "$ip_dir/IPQualityScore" ]]; then
        local ipqs_result
        ipqs_result=$(<"$ip_dir/IPQualityScore")
        local ipqs_status
        ipqs_status=$(echo "$ipqs_result" | cut -d'|' -f2)
        if [[ "$ipqs_status" =~ FAILED ]]; then
            fraud_score=75  # High risk
            proxy_score=50
        fi
    fi
    
    # Get AbuseIPDB data
    if [[ -f "$ip_dir/AbuseIPDB" ]]; then
        local abuse_result
        abuse_result=$(<"$ip_dir/AbuseIPDB")
        local abuse_status
        abuse_status=$(echo "$abuse_result" | cut -d'|' -f2)
        if [[ "$abuse_status" =~ FAILED ]]; then
            abuse_reports=50
        fi
    fi
    
    # Check Spamhaus
    if [[ "${SCORE_METRICS["${ip}_spamhaus_listed"]:-}" == "true" ]]; then
        abuse_reports=$((abuse_reports + 30))
    fi
    
    # Check datacenter
    if [[ "${SCORE_METRICS["${ip}_is_datacenter"]:-}" == "true" ]]; then
        is_datacenter=20
    fi
    
    # Calculate weighted score
    local penalty=0
    penalty=$(echo "scale=2; $fraud_score * 0.30 + $proxy_score * 0.20 + $vpn_score * 0.15 + $abuse_reports * 0.20 + $bot_activity * 0.10 + $is_datacenter * 0.05" | bc 2>/dev/null || echo "0")
    total_score=$(echo "scale=2; 100 - $penalty" | bc 2>/dev/null || echo "100")
    
    # Ensure score is between 0 and 100
    if (( $(echo "$total_score < 0" | bc -l 2>/dev/null || echo "0") )); then
        total_score=0
    elif (( $(echo "$total_score > 100" | bc -l 2>/dev/null || echo "0") )); then
        total_score=100
    fi
    
    SCORE_METRICS["${ip}_clean_score"]="$total_score"
    echo "$total_score"
}

generate_score_report() {
    local ip="$1"
    local score
    score=$(calculate_clean_score "$ip")
    
    local score_json
    score_json=$(jq -n \
        --arg ip "$ip" \
        --argjson score "$(echo "$score" | awk '{printf "%.2f", $1}')" \
        --arg fraud "${SCORE_METRICS["${ip}_fraud"]:-unknown}" \
        --arg proxy "${SCORE_METRICS["${ip}_proxy"]:-unknown}" \
        --arg vpn "${SCORE_METRICS["${ip}_vpn"]:-unknown}" \
        --arg abuse "${SCORE_METRICS["${ip}_abuse"]:-unknown}" \
        --arg bot "${SCORE_METRICS["${ip}_bot"]:-unknown}" \
        --arg datacenter "${SCORE_METRICS["${ip}_is_datacenter"]:-false}" \
        --arg asn "${SCORE_METRICS["${ip}_asn"]:-unknown}" \
        '{
            ip: $ip,
            clean_score: ($score | tonumber),
            metrics: {
                fraud_score: $fraud,
                proxy_score: $proxy,
                vpn_score: $vpn,
                recent_abuse_reports: $abuse,
                bot_activity: $bot,
                is_datacenter: ($datacenter == "true"),
                asn: $asn
            }
        }')
    
    echo "$score_json" > "$STATUS_DIR/$(echo "$ip" | tr '.' '_')/ip_score.json"
    log_message "Generated score report for $ip: Clean Score = $score" "INFO"
}

# --- CDN Detection Functions ---

detect_cdn() {
    local ip="$1" ip_dir="$2"
    log_message "Detecting CDN for $ip" "INFO"
    
    local cdn_detected="none"
    local cdn_provider=""
    local asn_info=""
    local reverse_dns=""
    
    # Get ASN info from ipapi if available
    if [[ -n "${SCORE_METRICS["${ip}_asn"]:-}" ]]; then
        asn_info="${SCORE_METRICS["${ip}_asn"]}"
    else
        # Quick ASN lookup
        local asn_resp
        asn_resp=$(curl --max-time 10 -sf "https://ipapi.co/$ip/json/" 2>/dev/null || true)
        if [[ -n "$asn_resp" ]]; then
            asn_info=$(jq -r '.asn // "unknown"' <<<"$asn_resp")
        fi
    fi
    
    # Reverse DNS lookup
    reverse_dns=$(dig +short -x "$ip" 2>/dev/null | head -1 || echo "")
    
    # Check for Cloudflare
    if [[ "$reverse_dns" =~ cloudflare ]] || [[ "$asn_info" == "13335" ]] || [[ "$asn_info" == "209242" ]]; then
        cdn_detected="cloudflare"
        cdn_provider="Cloudflare"
    # Check for Cloudflare Warp
    elif [[ "$reverse_dns" =~ warp ]] || [[ "$asn_info" == "13335" ]]; then
        cdn_detected="cloudflare_warp"
        cdn_provider="Cloudflare Warp"
    # Check for AWS CloudFront
    elif [[ "$reverse_dns" =~ cloudfront ]] || [[ "$asn_info" =~ ^(16509|14618|20547)$ ]]; then
        cdn_detected="aws_cloudfront"
        cdn_provider="AWS CloudFront"
    # Check for Google Cloud CDN
    elif [[ "$asn_info" =~ ^(15169|36040)$ ]]; then
        cdn_detected="gcp_cdn"
        cdn_provider="Google Cloud CDN"
    # Check for Azure CDN
    elif [[ "$asn_info" == "8075" ]] || [[ "$reverse_dns" =~ azure ]]; then
        cdn_detected="azure_cdn"
        cdn_provider="Azure CDN"
    # Check for Fastly
    elif [[ "$asn_info" == "54113" ]] || [[ "$reverse_dns" =~ fastly ]]; then
        cdn_detected="fastly"
        cdn_provider="Fastly"
    fi
    
    # Generate CDN status JSON
    local cdn_json
    cdn_json=$(jq -n \
        --arg ip "$ip" \
        --arg detected "$cdn_detected" \
        --arg provider "$cdn_provider" \
        --arg asn "$asn_info" \
        --arg rdns "$reverse_dns" \
        '{
            ip: $ip,
            cdn_detected: ($detected != "none"),
            cdn_type: $detected,
            provider: $provider,
            asn: $asn,
            reverse_dns: $rdns
        }')
    
    echo "$cdn_json" > "$ip_dir/cdn_status.json"
    CDN_RESULTS["$ip"]="$cdn_json"
    
    local details="Provider: $cdn_provider, ASN: $asn_info"
    if [[ "$cdn_detected" != "none" ]]; then
        write_status "$ip_dir" "CDN_Detection" "${YELLOW}DETECTED" "$details"
        log_message "CDN detected for $ip: $cdn_provider" "INFO"
    else
        write_status "$ip_dir" "CDN_Detection" "${GREEN}NONE" "$details"
        log_message "No CDN detected for $ip" "INFO"
    fi
}

# --- Routing Health Functions ---

test_routing() {
    local ip="$1" ip_dir="$2"
    log_message "Testing routing health for $ip" "INFO"
    
    if ! command -v traceroute &>/dev/null && ! command -v mtr &>/dev/null; then
        write_status "$ip_dir" "Routing_Health" "${YELLOW}SKIPPED" "traceroute/mtr not available"
        log_message "Routing test skipped: tools not available" "WARN"
        return
    fi
    
    local latency_results=()
    local packet_loss=0
    local hop_count=0
    local route_stable=true
    
    # Use mtr if available, otherwise traceroute
    if command -v mtr &>/dev/null; then
        log_message "Using mtr for routing test" "INFO"
        local mtr_output
        mtr_output=$(timeout 30 mtr -r -c 10 "$ip" 2>/dev/null || echo "")
        if [[ -n "$mtr_output" ]]; then
            packet_loss=$(echo "$mtr_output" | awk '/Loss%/{getline; print $3}' | sed 's/%//' || echo "0")
            hop_count=$(echo "$mtr_output" | grep -c "\. " || echo "0")
            local avg_latency
            avg_latency=$(echo "$mtr_output" | awk '/Avg/{getline; print $4}' || echo "0")
            latency_results+=("$avg_latency")
        fi
    elif command -v traceroute &>/dev/null; then
        log_message "Using traceroute for routing test" "INFO"
        local trace_output
        trace_output=$(timeout 30 traceroute -m 15 -q 1 "$ip" 2>/dev/null || echo "")
        if [[ -n "$trace_output" ]]; then
            hop_count=$(echo "$trace_output" | grep -c "  " || echo "0")
            local times
            times=$(echo "$trace_output" | grep -oE '[0-9]+\.[0-9]+ ms' | sed 's/ ms//' || echo "")
            if [[ -n "$times" ]]; then
                local total=0 count=0
                while IFS= read -r time; do
                    total=$(echo "$total + $time" | bc 2>/dev/null || echo "$total")
                    ((count++))
                done <<< "$times"
                if [[ $count -gt 0 ]]; then
                    local avg
                    avg=$(echo "scale=2; $total / $count" | bc 2>/dev/null || echo "0")
                    latency_results+=("$avg")
                fi
            fi
        fi
    fi
    
    # Simple ping test for latency
    local ping_result
    ping_result=$(ping -c 5 -W 2 "$ip" 2>/dev/null | tail -1 || echo "")
    local avg_ping=0
    if [[ -n "$ping_result" ]]; then
        avg_ping=$(echo "$ping_result" | grep -oE '[0-9]+\.[0-9]+' | head -1 || echo "0")
    fi
    
    # Generate routing report
    local route_json
    route_json=$(jq -n \
        --arg ip "$ip" \
        --argjson latency "${latency_results[0]:-$avg_ping}" \
        --argjson packet_loss "$packet_loss" \
        --argjson hops "$hop_count" \
        --arg stable "$route_stable" \
        '{
            ip: $ip,
            avg_latency_ms: ($latency | tonumber),
            packet_loss_percent: ($packet_loss | tonumber),
            hop_distance: ($hops | tonumber),
            route_stable: ($stable == "true")
        }')
    
    echo "$route_json" > "$ip_dir/route_report.json"
    ROUTING_RESULTS["$ip"]="$route_json"
    
    local details="Latency: ${latency_results[0]:-$avg_ping}ms, Hops: $hop_count, Loss: ${packet_loss}%"
    if (( $(echo "${packet_loss:-0} > 5" | bc -l 2>/dev/null || echo "0") )) || (( $(echo "${latency_results[0]:-$avg_ping} > 200" | bc -l 2>/dev/null || echo "0") )); then
        write_status "$ip_dir" "Routing_Health" "${RED}POOR" "$details"
        log_message "Routing health POOR for $ip: $details" "WARN"
    else
        write_status "$ip_dir" "Routing_Health" "${GREEN}GOOD" "$details"
        log_message "Routing health GOOD for $ip: $details" "INFO"
    fi
}

# --- Port Scanning Functions ---

scan_ports() {
    local ip="$1" ip_dir="$2"
    log_message "Scanning ports for $ip" "INFO"
    
    local ports=(22 80 443 8080 8443 53 3389)
    local open_ports=()
    local closed_ports=()
    local filtered_ports=()
    local risk_level="low"
    
    # Check for scanning tools
    local has_nc=false has_ss=false
    command -v nc &>/dev/null && has_nc=true
    command -v ss &>/dev/null && has_ss=true
    
    if ! $has_nc && ! $has_ss; then
        write_status "$ip_dir" "Port_Scan" "${YELLOW}SKIPPED" "nc/ss not available"
        log_message "Port scan skipped: tools not available" "WARN"
        return
    fi
    
    echo -e "${YELLOW}⚠️  Port scanning may be considered intrusive. Proceeding...${NC}" >&2
    
    for port in "${ports[@]}"; do
        local status="closed"
        if $has_nc; then
            if timeout 2 nc -z -v "$ip" "$port" &>/dev/null; then
                status="open"
                open_ports+=("$port")
            fi
        elif $has_ss; then
            # ss can't directly scan remote ports, use nc fallback or skip
            if timeout 2 bash -c "echo > /dev/tcp/$ip/$port" 2>/dev/null; then
                status="open"
                open_ports+=("$port")
            else
                status="closed"
                closed_ports+=("$port")
            fi
        fi
        log_message "Port $port: $status" "DEBUG"
    done
    
    # Assess risk
    local risk_score=0
    for port in "${open_ports[@]}"; do
        case "$port" in
            22) risk_score=$((risk_score + 5)) ;;   # SSH - normal
            80|443) risk_score=$((risk_score + 2)) ;; # HTTP/HTTPS - normal
            8080|8443) risk_score=$((risk_score + 10)) ;; # Alternative web ports - higher risk
            53) risk_score=$((risk_score + 15)) ;;   # DNS - unusual if open
            3389) risk_score=$((risk_score + 20)) ;; # RDP - high risk
        esac
    done
    
    if [[ $risk_score -ge 30 ]]; then
        risk_level="high"
    elif [[ $risk_score -ge 15 ]]; then
        risk_level="medium"
    fi
    
    # Generate port scan report
    local port_json
    port_json=$(jq -n \
        --arg ip "$ip" \
        --argjson open "$(IFS=','; echo "[${open_ports[*]}]")" \
        --argjson closed "$(IFS=','; echo "[${closed_ports[*]}]")" \
        --arg risk "$risk_level" \
        --argjson score "$risk_score" \
        '{
            ip: $ip,
            open_ports: ($open | fromjson),
            closed_ports: ($closed | fromjson),
            risk_level: $risk,
            risk_score: ($score | tonumber)
        }')
    
    echo "$port_json" > "$ip_dir/port_scan.json"
    PORT_RESULTS["$ip"]="$port_json"
    
    local details="Open: ${#open_ports[@]}, Risk: $risk_level"
    if [[ "$risk_level" == "high" ]]; then
        write_status "$ip_dir" "Port_Scan" "${RED}HIGH_RISK" "$details"
        log_message "Port scan HIGH RISK for $ip: $details" "WARN"
    elif [[ "$risk_level" == "medium" ]]; then
        write_status "$ip_dir" "Port_Scan" "${YELLOW}MEDIUM_RISK" "$details"
        log_message "Port scan MEDIUM RISK for $ip: $details" "INFO"
    else
        write_status "$ip_dir" "Port_Scan" "${GREEN}LOW_RISK" "$details"
        log_message "Port scan LOW RISK for $ip: $details" "INFO"
    fi
}

# --- Reality Fingerprint Testing Functions ---

test_reality_fingerprint() {
    local ip="$1" ip_dir="$2"
    log_message "Testing Reality fingerprint for $ip" "INFO"
    
    if ! command -v openssl &>/dev/null; then
        write_status "$ip_dir" "Reality_Test" "${YELLOW}SKIPPED" "openssl not available"
        log_message "Reality test skipped: openssl not available" "WARN"
        return
    fi
    
    local tls_errors=0
    local mtu_consistent=true
    local sni_works=false
    local routing_anomalies=false
    local ja3_fingerprint=""
    
    # Test TLS handshake
    log_message "Testing TLS handshake" "DEBUG"
    local tls_test
    tls_test=$(timeout 10 openssl s_client -connect "$ip:443" -servername "www.google.com" </dev/null 2>&1 || echo "")
    if echo "$tls_test" | grep -qi "verify error\|handshake failure\|connection refused"; then
        ((tls_errors++))
        log_message "TLS errors detected" "WARN"
    else
        log_message "TLS handshake successful" "INFO"
    fi
    
    # Test SNI behavior
    local sni_test
    sni_test=$(timeout 10 openssl s_client -connect "$ip:443" -servername "invalid-sni-test.example.com" </dev/null 2>&1 || echo "")
    if echo "$sni_test" | grep -qi "certificate"; then
        sni_works=true
        log_message "SNI works correctly" "INFO"
    else
        log_message "SNI test inconclusive" "DEBUG"
    fi
    
    # Test HTTP/2 if curl supports it
    if curl --version 2>/dev/null | grep -q "http2"; then
        log_message "Testing HTTP/2 support" "DEBUG"
        local http2_test
        http2_test=$(timeout 10 curl -sI --http2 "https://$ip" 2>&1 || echo "")
        if echo "$http2_test" | grep -qi "HTTP/2"; then
            log_message "HTTP/2 supported" "INFO"
        fi
    fi
    
    # Simple MTU consistency test (ping with different sizes)
    log_message "Testing MTU consistency" "DEBUG"
    local mtu_test1 mtu_test2
    mtu_test1=$(ping -c 1 -s 64 "$ip" 2>/dev/null | grep -oE 'time=[0-9.]+' || echo "")
    mtu_test2=$(ping -c 1 -s 1500 "$ip" 2>/dev/null | grep -oE 'time=[0-9.]+' || echo "")
    if [[ -n "$mtu_test1" ]] && [[ -n "$mtu_test2" ]]; then
        mtu_consistent=true
        log_message "MTU appears consistent" "INFO"
    else
        log_message "MTU test inconclusive" "DEBUG"
    fi
    
    # Generate Reality test report
    local reality_json
    reality_json=$(jq -n \
        --arg ip "$ip" \
        --argjson tls_errors "$tls_errors" \
        --arg mtu_consistent "$mtu_consistent" \
        --arg sni_works "$sni_works" \
        --arg routing_anomalies "$routing_anomalies" \
        --arg ja3 "$ja3_fingerprint" \
        '{
            ip: $ip,
            tls_handshake: ($tls_errors == 0),
            tls_errors: ($tls_errors | tonumber),
            mtu_consistent: ($mtu_consistent == "true"),
            sni_behavior: ($sni_works == "true"),
            routing_anomalies: ($routing_anomalies == "true"),
            ja3_fingerprint: $ja3,
            suitable_for_reality: (($tls_errors == 0) and ($mtu_consistent == "true"))
        }')
    
    echo "$reality_json" > "$ip_dir/reality_test.json"
    REALITY_RESULTS["$ip"]="$reality_json"
    
    local details="TLS OK: $((tls_errors == 0)), MTU: $mtu_consistent, SNI: $sni_works"
    if [[ $tls_errors -eq 0 ]] && [[ "$mtu_consistent" == "true" ]]; then
        write_status "$ip_dir" "Reality_Test" "${GREEN}SUITABLE" "$details"
        log_message "Reality test: IP is suitable for Sing-box Reality" "INFO"
    else
        write_status "$ip_dir" "Reality_Test" "${YELLOW}ISSUES" "$details"
        log_message "Reality test: IP has some issues" "WARN"
    fi
}

# --- Prior Usage Detection Functions ---

check_usage_history() {
    local ip="$1" ip_dir="$2"
    log_message "Checking usage history for $ip" "INFO"
    
    local allocation_age="unknown"
    local category_history="unknown"
    local fraud_history=false
    local vpn_detected=false
    local proxy_detected=false
    
    # Check AbuseIPDB for usage type
    if [[ -f "$ip_dir/AbuseIPDB" ]]; then
        local abuse_result
        abuse_result=$(<"$ip_dir/AbuseIPDB")
        local abuse_details
        abuse_details=$(echo "$abuse_result" | cut -d'|' -f3)
        if echo "$abuse_details" | grep -qiE "vpn|proxy|hosting|datacenter"; then
            if echo "$abuse_details" | grep -qi "vpn"; then
                vpn_detected=true
            fi
            if echo "$abuse_details" | grep -qi "proxy"; then
                proxy_detected=true
            fi
        fi
    fi
    
    # Check IPQS for usage type
    if [[ -f "$ip_dir/IPQualityScore" ]]; then
        local ipqs_result
        ipqs_result=$(<"$ip_dir/IPQualityScore")
        local ipqs_details
        ipqs_details=$(echo "$ipqs_result" | cut -d'|' -f3)
        if echo "$ipqs_details" | grep -qi "proxy.*true"; then
            proxy_detected=true
        fi
    fi
    
    # Check Scamalytics for fraud history
    if [[ -f "$ip_dir/Scamalytics" ]]; then
        local scam_result
        scam_result=$(<"$ip_dir/Scamalytics")
        local scam_status
        scam_status=$(echo "$scam_result" | cut -d'|' -f2)
        if echo "$scam_status" | grep -qi "FAILED"; then
            fraud_history=true
        fi
    fi
    
    # Try to get allocation info from RIPE/ARIN (simplified)
    local whois_info
    whois_info=$(whois "$ip" 2>/dev/null | head -20 || echo "")
    if [[ -n "$whois_info" ]]; then
        local org
        org=$(echo "$whois_info" | grep -iE "org-name|organization" | head -1 | cut -d: -f2 | xargs || echo "")
        if [[ -n "$org" ]]; then
            if echo "$org" | grep -qiE "vpn|proxy|hosting|datacenter"; then
                category_history="$org"
            fi
        fi
    fi
    
    # Generate usage history report
    local usage_json
    usage_json=$(jq -n \
        --arg ip "$ip" \
        --arg age "$allocation_age" \
        --arg category "$category_history" \
        --arg fraud "$fraud_history" \
        --arg vpn "$vpn_detected" \
        --arg proxy "$proxy_detected" \
        '{
            ip: $ip,
            allocation_age: $age,
            category_history: $category,
            fraud_history: ($fraud == "true"),
            vpn_detected: ($vpn == "true"),
            proxy_detected: ($proxy == "true"),
            prior_usage_risk: (if (($vpn == "true") or ($proxy == "true") or ($fraud == "true")) then "high" else "low" end)
        }')
    
    echo "$usage_json" > "$ip_dir/usage_history.json"
    USAGE_RESULTS["$ip"]="$usage_json"
    
    local details="VPN: $vpn_detected, Proxy: $proxy_detected, Fraud: $fraud_history"
    if $vpn_detected || $proxy_detected || $fraud_history; then
        write_status "$ip_dir" "Usage_History" "${RED}HIGH_RISK" "$details"
        log_message "Usage history HIGH RISK for $ip: $details" "WARN"
    else
        write_status "$ip_dir" "Usage_History" "${GREEN}LOW_RISK" "$details"
        log_message "Usage history LOW RISK for $ip: $details" "INFO"
    fi
}

# --- Suggestion Engine Functions ---

generate_suggestions() {
    local ip="$1" ip_dir="$2"
    log_message "Generating suggestions for $ip" "INFO"
    
    local suggestions=()
    local suggestion_categories=()
    
    # Load all results
    local clean_score=100
    local cdn_detected=false
    local routing_quality="good"
    local port_risk="low"
    local abuse_risk="low"
    local reality_suitable=false
    
    # Get Clean Score
    if [[ -f "$ip_dir/ip_score.json" ]]; then
        clean_score=$(jq -r '.clean_score // 100' "$ip_dir/ip_score.json" 2>/dev/null || echo "100")
    fi
    
    # Get CDN status
    if [[ -f "$ip_dir/cdn_status.json" ]]; then
        cdn_detected=$(jq -r '.cdn_detected // false' "$ip_dir/cdn_status.json" 2>/dev/null || echo "false")
    fi
    
    # Get routing quality
    if [[ -f "$ip_dir/route_report.json" ]]; then
        local packet_loss
        packet_loss=$(jq -r '.packet_loss_percent // 0' "$ip_dir/route_report.json" 2>/dev/null || echo "0")
        if (( $(echo "$packet_loss > 5" | bc -l 2>/dev/null || echo "0") )); then
            routing_quality="poor"
        fi
    fi
    
    # Get port risk
    if [[ -f "$ip_dir/port_scan.json" ]]; then
        port_risk=$(jq -r '.risk_level // "low"' "$ip_dir/port_scan.json" 2>/dev/null || echo "low")
    fi
    
    # Get abuse risk
    if [[ -f "$ip_dir/abuse_report.json" ]]; then
        local spamhaus_listed
        spamhaus_listed=$(jq -r '.spamhaus_listed // false' "$ip_dir/abuse_report.json" 2>/dev/null || echo "false")
        if [[ "$spamhaus_listed" == "true" ]]; then
            abuse_risk="high"
        fi
    fi
    
    # Get Reality suitability
    if [[ -f "$ip_dir/reality_test.json" ]]; then
        reality_suitable=$(jq -r '.suitable_for_reality // false' "$ip_dir/reality_test.json" 2>/dev/null || echo "false")
    fi
    
    # Generate suggestions based on results
    if (( $(echo "$clean_score < 50" | bc -l 2>/dev/null || echo "0") )); then
        suggestions+=("IP has low Clean Score ($clean_score). Consider using a different IP address.")
        suggestion_categories+=("security")
    fi
    
    if [[ "$cdn_detected" == "true" ]]; then
        suggestions+=("CDN detected. This IP may be behind a proxy/CDN, which can affect direct connectivity.")
        suggestion_categories+=("network")
    fi
    
    if [[ "$routing_quality" == "poor" ]]; then
        suggestions+=("Routing quality is poor. Check network configuration and consider alternative routes.")
        suggestion_categories+=("performance")
    fi
    
    if [[ "$port_risk" == "high" ]]; then
        suggestions+=("High port risk detected. Review open ports and firewall configuration.")
        suggestion_categories+=("security")
    fi
    
    if [[ "$abuse_risk" == "high" ]]; then
        suggestions+=("IP is listed in abuse databases. Request removal or use a different IP.")
        suggestion_categories+=("security")
    fi
    
    if [[ "$reality_suitable" == "true" ]]; then
        suggestions+=("IP is suitable for Sing-box Reality configuration.")
        suggestion_categories+=("configuration")
    else
        suggestions+=("IP may have issues with Sing-box Reality. Test TLS and MTU settings.")
        suggestion_categories+=("configuration")
    fi
    
    # Generate suggestions JSON
    local suggestions_array="["
    local first=true
    for i in "${!suggestions[@]}"; do
        if ! $first; then suggestions_array+=","; fi
        first=false
        suggestions_array+=$(jq -n \
            --arg text "${suggestions[$i]}" \
            --arg category "${suggestion_categories[$i]}" \
            '{text: $text, category: $category, priority: "medium"}')
    done
    suggestions_array+="]"
    
    local suggestions_json
    suggestions_json=$(jq -n \
        --arg ip "$ip" \
        --argjson suggestions "$suggestions_array" \
        '{
            ip: $ip,
            suggestions: ($suggestions | fromjson),
            generated_at: (now | todateiso8601)
        }')
    
    echo "$suggestions_json" > "$ip_dir/suggestions.json"
    log_message "Generated ${#suggestions[@]} suggestions for $ip" "INFO"
}

# --- Reporting Functions ---

generate_table_report() {
    local ip="$1" ip_dir="$2" fail_threshold="$3"
    local failed_checks=0

    # Get Clean Score if available
    local clean_score="N/A"
    if [[ -f "$ip_dir/ip_score.json" ]]; then
        clean_score=$(jq -r '.clean_score // "N/A"' "$ip_dir/ip_score.json" 2>/dev/null || echo "N/A")
        if [[ "$clean_score" != "N/A" ]] && command -v bc &>/dev/null; then
            clean_score=$(printf "%.0f" "$clean_score" 2>/dev/null || echo "$clean_score")
        fi
    else
        # Calculate score on the fly if not generated
        if command -v bc &>/dev/null; then
            clean_score=$(calculate_clean_score "$ip" 2>/dev/null || echo "N/A")
            if [[ "$clean_score" != "N/A" ]]; then
                clean_score=$(printf "%.0f" "$clean_score" 2>/dev/null || echo "$clean_score")
            fi
        fi
    fi

    printf "\n${BLUE}┌─────────────────── IP Reputation Report for %-35s ┐${NC}\n" "$ip"
    if [[ "$clean_score" != "N/A" ]]; then
        printf "${BLUE}│ ${GREEN}Clean Score: ${YELLOW}%s/100${BLUE}%*s │${NC}\n" "$clean_score" $((58 - ${#clean_score})) ""
    fi
    printf "${BLUE}│ %-18s │ %-15s │ %-42s │${NC}\n" "Service" "Status" "Details"
    printf "${BLUE}├────────────────────┼─────────────────┼────────────────────────────────────────────┤${NC}\n"

    for check_file in "$ip_dir"/*; do
        [[ ! -f "$check_file" ]] && continue
        local check_name=$(basename "$check_file")
        # Skip raw data files and JSON reports
        [[ "$check_name" == raw_* ]] && continue
        [[ "$check_name" == *.json ]] && continue
        
        local result status details status_code
        result=$(<"$check_file")
        status_code=$(echo "$result" | cut -d'|' -f1)
        status=$(echo "$result" | cut -d'|' -f2)
        details=$(echo "$result" | cut -d'|' -f3)

        if ((status_code == 1 || status_code == 3)); then
            ((failed_checks++))
        fi

        printf "│ %-18s │ %-15s │ %-42s │\n" "$check_name" "${status}${NC}" "$details"
    done

    printf "${BLUE}└────────────────────┴─────────────────┴────────────────────────────────────────────┘${NC}\n\n"

    if ((failed_checks >= fail_threshold)); then
        echo -e "${RED}❌ Overall Status: FAILED. Found $failed_checks failed checks (threshold is $fail_threshold).${NC}"
        return 1
    else
        echo -e "${GREEN}✅ Overall Status: PASSED. Found $failed_checks failed checks (threshold is $fail_threshold).${NC}"
        return 0
    fi
}

# Generate structured data (JSON) for all IPs
generate_data_report() {
    local all_ips_str="$1" fail_threshold="$2"
    local -a all_ips
    mapfile -t all_ips <<<"$all_ips_str"

    local json_output="["
    local first_ip=true
    local overall_exit_code=0

    for ip in "${all_ips[@]}"; do
        if ! $first_ip; then json_output+=","; fi
        first_ip=false

        local ip_dir="$STATUS_DIR/$(echo "$ip" | tr '.' '_')"
        local ip_json
        ip_json=$(jq -n --arg ip "$ip" '{ip: $ip, checks: {}, raw_data: {}}')
        local failed_checks=0

        # Get Clean Score if available
        local clean_score="unknown"
        if [[ -f "$ip_dir/ip_score.json" ]]; then
            clean_score=$(jq -r '.clean_score // "unknown"' "$ip_dir/ip_score.json" 2>/dev/null || echo "unknown")
        else
            # Calculate score on the fly if not generated
            if command -v bc &>/dev/null; then
                clean_score=$(calculate_clean_score "$ip" 2>/dev/null || echo "unknown")
            fi
        fi

        # Collect raw API data
        local raw_data_json="{}"
        for raw_file in "$ip_dir"/raw_*.json "$ip_dir"/raw_*.txt; do
            [[ ! -f "$raw_file" ]] && continue
            local raw_name=$(basename "$raw_file" | sed 's/^raw_//; s/\.json$//; s/\.txt$//')
            if [[ "$raw_file" == *.json ]]; then
                local raw_content
                raw_content=$(<"$raw_file")
                raw_data_json=$(echo "$raw_data_json" | jq --arg name "$raw_name" --argjson content "$raw_content" '.[$name] = $content' 2>/dev/null || echo "$raw_data_json")
            else
                local raw_content
                raw_content=$(<"$raw_file")
                raw_data_json=$(echo "$raw_data_json" | jq --arg name "$raw_name" --arg content "$raw_content" '.[$name] = $content' 2>/dev/null || echo "$raw_data_json")
            fi
        done

        for check_file in "$ip_dir"/*; do
            [[ ! -f "$check_file" ]] && continue
            local check_name=$(basename "$check_file")
            # Skip raw data files and JSON reports
            [[ "$check_name" == raw_* ]] && continue
            [[ "$check_name" == *.json ]] && [[ "$check_name" != ip_score.json ]] && continue
            
            local result status_text details status_code
            result=$(<"$check_file")
            status_code=$(echo "$result" | cut -d'|' -f1)
            status_text=$(echo "$result" | cut -d'|' -f2 | sed "s/$(printf '\033')\\[[0-9;]*m//g") # Strip colors
            details=$(echo "$result" | cut -d'|' -f3)

            if ((status_code == 1 || status_code == 3)); then
                ((failed_checks++))
            fi

            local check_json
            check_json=$(jq -n --arg status "$status_text" --arg details "$details" '{status: $status, details: $details}')
            ip_json=$(echo "$ip_json" | jq --argjson check "$check_json" --arg name "$check_name" '.checks[$name] = $check')
        done

        local overall_status="PASSED"
        if ((failed_checks >= fail_threshold)); then
            overall_status="FAILED"
            overall_exit_code=1
        fi

        # Add Clean Score and raw data to JSON
        ip_json=$(echo "$ip_json" | jq \
            --arg status "$overall_status" \
            --argint failed "$failed_checks" \
            --argint thresh "$fail_threshold" \
            --arg score "$clean_score" \
            --argjson raw_data "$raw_data_json" \
            '.overall_status = $status | 
             .failed_checks = $failed | 
             .failure_threshold = $thresh |
             .clean_score = (if $score == "unknown" then null else ($score | tonumber) end) |
             .raw_data = $raw_data')

        json_output+="$ip_json"
    done

    json_output+="]"
    echo "$json_output" | jq . # Pretty-print JSON
    return $overall_exit_code
}

# Convert JSON to YAML
json_to_yaml() {
    local json_data="$1"
    # Use yq if available, otherwise use a simple converter
    if command -v yq &>/dev/null; then
        echo "$json_data" | yq -P .
    elif command -v python3 &>/dev/null; then
        echo "$json_data" | python3 -c "
import json, sys, yaml
try:
    data = json.load(sys.stdin)
    print(yaml.dump(data, default_flow_style=False, allow_unicode=True))
except ImportError:
    print('# YAML output requires PyYAML. Install: pip install pyyaml', file=sys.stderr)
    sys.exit(1)
" 2>/dev/null || echo "$json_data" | jq -r 'to_entries | .[] | "\(.key): \(.value)"' | sed 's/^/  /'
    else
        # Fallback: simple YAML-like output
        echo "$json_data" | jq -r '
            def to_yaml:
                if type == "object" then
                    to_entries | .[] | "\(.key):\n\(.value | to_yaml | split("\n") | .[] | "  " + .)"
                elif type == "array" then
                    .[] | "- \(to_yaml)"
                else
                    "\(.)"
                end;
            to_yaml
        ' 2>/dev/null || echo "$json_data"
    fi
}

# Convert JSON to CSV
json_to_csv() {
    local json_data="$1"
    echo "$json_data" | jq -r '
        ["IP", "Clean Score", "Overall Status", "Failed Checks", "Failure Threshold"],
        (.[] | [.ip, (.clean_score // "N/A"), .overall_status, .failed_checks, .failure_threshold])
        | @csv
    ' 2>/dev/null || echo "IP,Clean Score,Overall Status,Failed Checks,Failure Threshold"
}

# Convert JSON to XML
json_to_xml() {
    local json_data="$1"
    echo '<?xml version="1.0" encoding="UTF-8"?>'
    echo '<ipcheck_results>'
    echo "$json_data" | jq -r '
        .[] | "
  <ip_result>
    <ip>\(.ip)</ip>
    <clean_score>\(.clean_score // "N/A")</clean_score>
    <overall_status>\(.overall_status)</overall_status>
    <failed_checks>\(.failed_checks)</failed_checks>
    <failure_threshold>\(.failure_threshold)</failure_threshold>
    <checks>\(.checks | to_entries | .[] | "
      <check>
        <name>\(.key)</name>
        <status>\(.value.status)</status>
        <details>\(.value.details)</details>
      </check>")</checks>
  </ip_result>"
    ' 2>/dev/null
    echo '</ipcheck_results>'
}

# Generate report in specified format
generate_json_report() {
    local all_ips_str="$1" fail_threshold="$2"
    local json_data
    json_data=$(generate_data_report "$all_ips_str" "$fail_threshold")
    local exit_code=$?
    echo "$json_data"
    return $exit_code
}

generate_yaml_report() {
    local all_ips_str="$1" fail_threshold="$2"
    local json_data
    json_data=$(generate_data_report "$all_ips_str" "$fail_threshold")
    local exit_code=$?
    json_to_yaml "$json_data"
    return $exit_code
}

generate_csv_report() {
    local all_ips_str="$1" fail_threshold="$2"
    local json_data
    json_data=$(generate_data_report "$all_ips_str" "$fail_threshold")
    local exit_code=$?
    json_to_csv "$json_data"
    return $exit_code
}

generate_xml_report() {
    local all_ips_str="$1" fail_threshold="$2"
    local json_data
    json_data=$(generate_data_report "$all_ips_str" "$fail_threshold")
    local exit_code=$?
    json_to_xml "$json_data"
    return $exit_code
}

generate_yaml_report() {
    local all_ips_str="$1" fail_threshold="$2"
    local json_data
    json_data=$(generate_data_report "$all_ips_str" "$fail_threshold")
    local exit_code=$?
    json_to_yaml "$json_data"
    return $exit_code
}

generate_csv_report() {
    local all_ips_str="$1" fail_threshold="$2"
    local json_data
    json_data=$(generate_data_report "$all_ips_str" "$fail_threshold")
    local exit_code=$?
    json_to_csv "$json_data"
    return $exit_code
}

generate_xml_report() {
    local all_ips_str="$1" fail_threshold="$2"
    local json_data
    json_data=$(generate_data_report "$all_ips_str" "$fail_threshold")
    local exit_code=$?
    json_to_xml "$json_data"
    return $exit_code
}

# --- Interactive Menu Functions ---

show_logo() {
    echo -e "${BLUE}"
    echo "    ██╗██████╗  ██████╗██╗  ██╗███████╗ ██████╗██╗  ██╗"
    echo "    ██║██╔══██╗██╔════╝██║  ██║██╔════╝██╔════╝██║ ██╔╝"
    echo "    ██║██████╔╝██║     ███████║█████╗  ██║     █████╔╝"
    echo "    ██║██╔═══╝ ██║     ██╔══██║██╔══╝  ██║     ██╔═██╗"
    echo "    ██║██║     ╚██████╗██║  ██║███████╗╚██████╗██║  ██╗"
    echo "    ╚═╝╚═╝      ╚═════╝╚═╝  ╚═╝╚══════╝ ╚═════╝╚═╝  ╚═╝"
    echo "    ════════════════════════════════════════════════════"
    echo "    Advanced IP Reputation Checker v2.1.6"
    echo -e "${NC}"
    echo
}

show_main_menu() {
    show_logo
    
    echo -e "${GREEN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "${BLUE}📋 Main Menu / منوی اصلی${NC}"
    echo -e "${GREEN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}\n"
    
    echo -e "${YELLOW}┌────────────────────────────────────────────────────────────────────────────┐${NC}"
    echo -e "${YELLOW}│${NC}  ${GREEN}1)${NC} ${BLUE}🔍 Check IP Address${NC} / ${BLUE}بررسی آدرس IP${NC}"
    echo -e "${YELLOW}│${NC}     ${YELLOW}→${NC} Analyze IP reputation, quality score, CDN detection, routing health"
    echo -e "${YELLOW}│${NC}     ${YELLOW}→${NC} بررسی اعتبار IP، امتیاز کیفیت، تشخیص CDN، سلامت مسیریابی"
    echo -e "${YELLOW}│${NC}"
    echo -e "${YELLOW}│${NC}  ${GREEN}2)${NC} ${BLUE}🔧 Install VPN Server${NC} / ${BLUE}نصب سرور VPN${NC}"
    echo -e "${YELLOW}│${NC}     ${YELLOW}→${NC} Install Sing-box, Xray, V2Ray, Shadowsocks, OpenVPN, or OpenConnect"
    echo -e "${YELLOW}│${NC}     ${YELLOW}→${NC} نصب Sing-box، Xray، V2Ray، Shadowsocks، OpenVPN یا OpenConnect"
    echo -e "${YELLOW}│${NC}"
    echo -e "${YELLOW}│${NC}  ${GREEN}3)${NC} ${BLUE}🗑️  Uninstall IPCheck${NC} / ${BLUE}حذف IPCheck${NC}"
    echo -e "${YELLOW}│${NC}     ${YELLOW}→${NC} Remove IPCheck from your system"
    echo -e "${YELLOW}│${NC}     ${YELLOW}→${NC} حذف IPCheck از سیستم شما"
    echo -e "${YELLOW}│${NC}"
    echo -e "${YELLOW}│${NC}  ${GREEN}4)${NC} ${BLUE}❌ Exit${NC} / ${BLUE}خروج${NC}"
    echo -e "${YELLOW}│${NC}     ${YELLOW}→${NC} Exit the application"
    echo -e "${YELLOW}│${NC}     ${YELLOW}→${NC} خروج از برنامه"
    echo -e "${YELLOW}└────────────────────────────────────────────────────────────────────────────┘${NC}"
    echo
    echo -e "${GREEN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
}

show_ip_check_menu() {
    clear
    show_logo
    echo -e "${GREEN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "${BLUE}📋 IP Check Options / گزینه‌های بررسی IP${NC}"
    echo -e "${GREEN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}\n"
    
    echo -e "${YELLOW}┌────────────────────────────────────────────────────────────────────────────┐${NC}"
    echo -e "${YELLOW}│${NC}  ${BLUE}Input Method / روش ورودی:${NC}"
    echo -e "${YELLOW}│${NC}"
    echo -e "${YELLOW}│${NC}  ${GREEN}1)${NC} ${BLUE}✍️  Enter IP address(es) manually${NC} / ${BLUE}وارد کردن دستی آدرس IP${NC}"
    echo -e "${YELLOW}│${NC}     ${YELLOW}→${NC} Type one or more IP addresses (comma-separated)"
    echo -e "${YELLOW}│${NC}     ${YELLOW}→${NC} وارد کردن یک یا چند آدرس IP (جدا شده با کاما)"
    echo -e "${YELLOW}│${NC}"
    echo -e "${YELLOW}│${NC}  ${GREEN}2)${NC} ${BLUE}🖥️  Check server's public IP${NC} / ${BLUE}بررسی IP عمومی سرور${NC}"
    echo -e "${YELLOW}│${NC}     ${YELLOW}→${NC} Automatically detect and check this server's public IP"
    echo -e "${YELLOW}│${NC}     ${YELLOW}→${NC} تشخیص و بررسی خودکار IP عمومی این سرور"
    echo -e "${YELLOW}│${NC}"
    echo -e "${YELLOW}│${NC}  ${GREEN}3)${NC} ${BLUE}📄 Load from file${NC} / ${BLUE}بارگذاری از فایل${NC}"
    echo -e "${YELLOW}│${NC}     ${YELLOW}→${NC} Load IP addresses from a text file (one per line)"
    echo -e "${YELLOW}│${NC}     ${YELLOW}→${NC} بارگذاری آدرس‌های IP از فایل متنی (هر خط یک IP)"
    echo -e "${YELLOW}│${NC}"
    echo -e "${YELLOW}│${NC}  ${GREEN}4)${NC} ${BLUE}⬅️  Back to main menu${NC} / ${BLUE}بازگشت به منوی اصلی${NC}"
    echo -e "${YELLOW}└────────────────────────────────────────────────────────────────────────────┘${NC}"
    echo
    echo -e "${GREEN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -ne "${BLUE}👉 Select input method (1-4): ${NC}"
    
    local input_method=""
    if [[ -c /dev/tty ]] && [[ -r /dev/tty ]]; then
        exec 3< /dev/tty
        IFS= read -r input_method <&3
        exec 3<&-
    elif [[ -t 0 ]]; then
        IFS= read -r input_method
    else
        exec 3< /dev/tty 2>/dev/null
        if [[ $? -eq 0 ]]; then
            IFS= read -r input_method <&3
            exec 3<&-
        else
            IFS= read -r input_method || input_method=""
        fi
    fi
    input_method=$(printf '%s' "$input_method" | tr -d '\n\r' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
    
    local ip_input=""
    local result=""
    case "$input_method" in
        1)
            echo
            echo -e "${GREEN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
            echo -ne "${BLUE}📝 Enter IP address(es) (comma-separated): ${NC}"
            if [[ -c /dev/tty ]] && [[ -r /dev/tty ]]; then
                exec 3< /dev/tty
                IFS= read -r ip_input <&3
                exec 3<&-
            else
                IFS= read -r ip_input
            fi
            ip_input=$(printf '%s' "$ip_input" | tr -d '\n\r' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            if [[ -z "$ip_input" ]]; then
                echo -e "${YELLOW}⚠ No IP address entered. Cancelling...${NC}"
                result="INPUT:CANCEL"
            else
                result="INPUT:$ip_input"
            fi
            ;;
        2)
            result="INPUT:--server"
            ;;
        3)
            echo
            echo -e "${GREEN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
            echo -ne "${BLUE}📁 Enter file path: ${NC}"
            if [[ -c /dev/tty ]] && [[ -r /dev/tty ]]; then
                exec 3< /dev/tty
                IFS= read -r file_path <&3
                exec 3<&-
            else
                IFS= read -r file_path
            fi
            file_path=$(printf '%s' "$file_path" | tr -d '\n\r' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            if [[ -z "$file_path" ]]; then
                echo -e "${YELLOW}⚠ No file path entered. Cancelling...${NC}"
                result="INPUT:CANCEL"
            else
                result="INPUT:--file:$file_path"
            fi
            ;;
        4)
            result="INPUT:CANCEL"
            ;;
        *)
            echo -e "${YELLOW}⚠ Invalid option.${NC}"
            sleep 1
            result="INPUT:CANCEL"
            ;;
    esac
    
    # Store result in global variable
    IPCHECK_MENU_RESULT="$result"
}

show_check_options_menu() {
    local selected_flags=""
    
    while true; do
        clear
        show_logo
        echo -e "${GREEN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo -e "${BLUE}Select Check Options / انتخاب گزینه‌های بررسی${NC}"
        echo -e "${GREEN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}\n"
        
        echo -e "${BLUE}Basic Checks / بررسی‌های پایه:${NC}"
        local q_mark=" " a_mark=" " s_mark=" " r_mark=" " c_mark=" " h_mark=" "
        [[ "$selected_flags" == *"q"* ]] && q_mark="✓"
        [[ "$selected_flags" == *"a"* ]] && a_mark="✓"
        [[ "$selected_flags" == *"s"* ]] && s_mark="✓"
        [[ "$selected_flags" == *"r"* ]] && r_mark="✓"
        [[ "$selected_flags" == *"c"* ]] && c_mark="✓"
        [[ "$selected_flags" == *"h"* ]] && h_mark="✓"
        echo -e "  ${YELLOW}[$q_mark]${NC} q - IPQualityScore"
        echo -e "  ${YELLOW}[$a_mark]${NC} a - AbuseIPDB"
        echo -e "  ${YELLOW}[$s_mark]${NC} s - Scamalytics"
        echo -e "  ${YELLOW}[$r_mark]${NC} r - RIPE Atlas"
        echo -e "  ${YELLOW}[$c_mark]${NC} c - Check-Host"
        echo -e "  ${YELLOW}[$h_mark]${NC} h - HostTracker"
        
        echo -e "\n${BLUE}Advanced Features / ویژگی‌های پیشرفته:${NC}"
        local g_mark=" " d_mark=" " t_mark=" " p_mark=" " R_mark=" " u_mark=" " n_mark=" "
        [[ "$selected_flags" == *"g"* ]] && g_mark="✓"
        [[ "$selected_flags" == *"d"* ]] && d_mark="✓"
        [[ "$selected_flags" == *"t"* ]] && t_mark="✓"
        [[ "$selected_flags" == *"p"* ]] && p_mark="✓"
        [[ "$selected_flags" == *"R"* ]] && R_mark="✓"
        [[ "$selected_flags" == *"u"* ]] && u_mark="✓"
        [[ "$selected_flags" == *"n"* ]] && n_mark="✓"
        echo -e "  ${YELLOW}[$g_mark]${NC} g - IP Quality Score"
        echo -e "  ${YELLOW}[$d_mark]${NC} d - CDN Detection"
        echo -e "  ${YELLOW}[$t_mark]${NC} t - Routing Health"
        echo -e "  ${YELLOW}[$p_mark]${NC} p - Port Scan"
        echo -e "  ${YELLOW}[$R_mark]${NC} R - Reality Test"
        echo -e "  ${YELLOW}[$u_mark]${NC} u - Usage History"
        echo -e "  ${YELLOW}[$n_mark]${NC} n - Suggestions"
        
        echo -e "\n${BLUE}Output Options / گزینه‌های خروجی:${NC}"
        local j_mark=" " l_mark=" "
        [[ "$selected_flags" == *"j"* ]] && j_mark="✓"
        [[ "$selected_flags" == *"l"* ]] && l_mark="✓"
        echo -e "  ${YELLOW}[$j_mark]${NC} j - JSON Output"
        echo -e "  ${YELLOW}[$l_mark]${NC} l - Enable Logging"
        
        echo -e "\n${GREEN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        if [[ -n "$selected_flags" ]]; then
            echo -e "${BLUE}Selected flags: ${GREEN}${selected_flags}${NC}"
        else
            echo -e "${BLUE}Selected flags: ${YELLOW}none (will run all basic checks)${NC}"
        fi
        echo -e "${GREEN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}\n"
        echo -e "${BLUE}Instructions:${NC}"
        echo -e "  • Type flag letters to toggle (e.g., ${YELLOW}gdt${NC} to toggle g, d, t)"
        echo -e "  • Press ${YELLOW}[Enter]${NC} to run with current selection"
        echo -e "  • ${YELLOW}[a]${NC} = Select all / ${YELLOW}[c]${NC} = Clear all / ${YELLOW}[d]${NC} = Done"
        echo
        read -p "Your choice: " choice
        
        case "$choice" in
            "")
                if [[ -n "$selected_flags" ]]; then
                    IPCHECK_MENU_RESULT="FLAGS:$selected_flags"
                    return
                else
                    IPCHECK_MENU_RESULT="FLAGS:all"
                    return
                fi
                ;;
            "c"|"C")
                selected_flags=""
                ;;
            "a"|"A")
                selected_flags="qasrchgdtpRunjl"
                ;;
            "d"|"D")
                IPCHECK_MENU_RESULT="FLAGS:$selected_flags"
                return
                ;;
            *)
                # Toggle flags - handle both single and multiple characters
                for (( i=0; i<${#choice}; i++ )); do
                    local char="${choice:$i:1}"
                    # Skip if it's a command character
                    [[ "$char" == "a" ]] && [[ ${#choice} -eq 1 ]] && continue
                    [[ "$char" == "c" ]] && [[ ${#choice} -eq 1 ]] && continue
                    [[ "$char" == "d" ]] && [[ ${#choice} -eq 1 ]] && continue
                    
                    if [[ "$selected_flags" == *"$char"* ]]; then
                        selected_flags="${selected_flags//$char/}"
                    else
                        selected_flags+="$char"
                    fi
                done
                ;;
        esac
    done
}

show_vpn_menu() {
    show_logo
    echo -e "${GREEN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "${BLUE}🔧 VPN Installation / نصب VPN${NC}"
    echo -e "${GREEN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}\n"
    
    if [[ $EUID -ne 0 ]]; then
        echo -e "${RED}╔══════════════════════════════════════════════════════════════╗${NC}"
        echo -e "${RED}║${NC}                                                              ${RED}║${NC}"
        echo -e "${RED}║${NC}  ${YELLOW}⚠️  Error: VPN installation requires root privileges${NC}          ${RED}║${NC}"
        echo -e "${RED}║${NC}                                                              ${RED}║${NC}"
        echo -e "${RED}║${NC}  ${YELLOW}Please run with: ${GREEN}sudo ipcheck${NC}                              ${RED}║${NC}"
        echo -e "${RED}║${NC}                                                              ${RED}║${NC}"
        echo -e "${RED}╚══════════════════════════════════════════════════════════════╝${NC}"
        echo
        echo -ne "${BLUE}Press Enter to continue...${NC}"
        if [[ -c /dev/tty ]] && [[ -r /dev/tty ]]; then
            exec 3< /dev/tty
            IFS= read -r <&3
            exec 3<&-
        else
            IFS= read -r
        fi
        return
    fi
    
    echo -e "${YELLOW}┌────────────────────────────────────────────────────────────────────────────┐${NC}"
    echo -e "${YELLOW}│${NC}  ${BLUE}Select VPN to install / انتخاب VPN برای نصب:${NC}"
    echo -e "${YELLOW}│${NC}"
    echo -e "${YELLOW}│${NC}  ${GREEN}1)${NC} ${BLUE}🚀 Sing-box${NC} (Recommended for Reality / توصیه شده برای Reality)"
    echo -e "${YELLOW}│${NC}     ${YELLOW}→${NC} Modern, lightweight, supports Reality protocol"
    echo -e "${YELLOW}│${NC}     ${YELLOW}→${NC} مدرن، سبک، پشتیبانی از پروتکل Reality"
    echo -e "${YELLOW}│${NC}"
    echo -e "${YELLOW}│${NC}  ${GREEN}2)${NC} ${BLUE}⚡ Xray${NC} (Xray-core)"
    echo -e "${YELLOW}│${NC}     ${YELLOW}→${NC} High-performance proxy platform"
    echo -e "${YELLOW}│${NC}     ${YELLOW}→${NC} پلتفرم پروکسی با عملکرد بالا"
    echo -e "${YELLOW}│${NC}"
    echo -e "${YELLOW}│${NC}  ${GREEN}3)${NC} ${BLUE}🌐 V2Ray${NC} (V2Fly)"
    echo -e "${YELLOW}│${NC}     ${YELLOW}→${NC} Popular proxy platform with extensive features"
    echo -e "${YELLOW}│${NC}     ${YELLOW}→${NC} پلتفرم پروکسی محبوب با ویژگی‌های گسترده"
    echo -e "${YELLOW}│${NC}"
    echo -e "${YELLOW}│${NC}  ${GREEN}4)${NC} ${BLUE}🔒 Shadowsocks-libev${NC}"
    echo -e "${YELLOW}│${NC}     ${YELLOW}→${NC} Lightweight SOCKS5 proxy"
    echo -e "${YELLOW}│${NC}     ${YELLOW}→${NC} پروکسی SOCKS5 سبک"
    echo -e "${YELLOW}│${NC}"
    echo -e "${YELLOW}│${NC}  ${GREEN}5)${NC} ${BLUE}🛡️  OpenVPN${NC}"
    echo -e "${YELLOW}│${NC}     ${YELLOW}→${NC} Industry-standard VPN protocol"
    echo -e "${YELLOW}│${NC}     ${YELLOW}→${NC} پروتکل VPN استاندارد صنعتی"
    echo -e "${YELLOW}│${NC}"
    echo -e "${YELLOW}│${NC}  ${GREEN}6)${NC} ${BLUE}🔐 OpenConnect${NC} (Cisco AnyConnect compatible)"
    echo -e "${YELLOW}│${NC}     ${YELLOW}→${NC} Compatible with Cisco AnyConnect VPN"
    echo -e "${YELLOW}│${NC}     ${YELLOW}→${NC} سازگار با VPN Cisco AnyConnect"
    echo -e "${YELLOW}│${NC}"
    echo -e "${YELLOW}│${NC}  ${GREEN}7)${NC} ${BLUE}⬅️  Back to main menu${NC} / ${BLUE}بازگشت به منوی اصلی${NC}"
    echo -e "${YELLOW}└────────────────────────────────────────────────────────────────────────────┘${NC}"
    echo
    echo -e "${GREEN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -ne "${BLUE}👉 Select option (1-7): ${NC}"
    
    local vpn_choice=""
    if [[ -c /dev/tty ]] && [[ -r /dev/tty ]]; then
        exec 3< /dev/tty
        IFS= read -r vpn_choice <&3
        exec 3<&-
    elif [[ -t 0 ]]; then
        IFS= read -r vpn_choice
    else
        exec 3< /dev/tty 2>/dev/null
        if [[ $? -eq 0 ]]; then
            IFS= read -r vpn_choice <&3
            exec 3<&-
        else
            IFS= read -r vpn_choice || vpn_choice=""
        fi
    fi
    vpn_choice=$(printf '%s' "$vpn_choice" | tr -d '\n\r' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
    
    case "$vpn_choice" in
        1) install_singbox ;;
        2) install_xray ;;
        3) install_v2ray ;;
        4) install_shadowsocks ;;
        5) install_openvpn ;;
        6) install_cisco ;;
        7) return ;;
        *)
            echo -e "${YELLOW}⚠ Invalid option.${NC}"
            sleep 1
            ;;
    esac
    
    if [[ "$vpn_choice" =~ ^[1-6]$ ]]; then
        echo
        echo -ne "${BLUE}Press Enter to continue...${NC}"
        if [[ -c /dev/tty ]] && [[ -r /dev/tty ]]; then
            exec 3< /dev/tty
            IFS= read -r <&3
            exec 3<&-
        else
            IFS= read -r
        fi
    fi
}

interactive_menu() {
    while true; do
        show_main_menu
        
        # Read input directly (not from command substitution)
        echo -ne "${BLUE}👉 Select an option (1-4): ${NC}"
        local main_choice=""
        
        # Force read from /dev/tty
        if [[ -c /dev/tty ]] && [[ -r /dev/tty ]]; then
            exec 3< /dev/tty
            IFS= read -r main_choice <&3
            exec 3<&-
        elif [[ -t 0 ]]; then
            IFS= read -r main_choice
        else
            exec 3< /dev/tty 2>/dev/null
            if [[ $? -eq 0 ]]; then
                IFS= read -r main_choice <&3
                exec 3<&-
            else
                IFS= read -r main_choice || main_choice=""
            fi
        fi
        
        # Trim whitespace and newlines
        main_choice=$(printf '%s' "$main_choice" | tr -d '\n\r' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
        
        case "$main_choice" in
            1)
                # Call menu directly (it displays itself)
                show_ip_check_menu
                local input_result="$IPCHECK_MENU_RESULT"
                
                if [[ -z "$input_result" ]] || [[ "$input_result" == "INPUT:CANCEL" ]]; then
                    continue
                fi
                
                # Call check options menu directly
                show_check_options_menu
                local check_result="$IPCHECK_MENU_RESULT"
                
                if [[ "$check_result" == "FLAGS:"* ]]; then
                    local flags="${check_result#FLAGS:}"
                    local input="${input_result#INPUT:}"
                    
                    # Build command
                    local cmd_args=()
                    
                    if [[ "$input" == "--server" ]]; then
                        cmd_args+=("-S")
                    elif [[ "$input" == --file:* ]]; then
                        cmd_args+=("-f" "${input#--file:}")
                    else
                        cmd_args+=("-i" "$input")
                    fi
                    
                    # Add flags
                    if [[ "$flags" != "all" ]] && [[ -n "$flags" ]]; then
                        # Add individual flags or combined
                        if [[ ${#flags} -gt 1 ]]; then
                            # Combined flags like "gdt"
                            cmd_args+=("-$flags")
                        else
                            # Single flag
                            cmd_args+=("-$flags")
                        fi
                    fi
                    
                    # Execute
                    echo -e "\n${BLUE}Running: ipcheck ${cmd_args[*]}${NC}\n"
                    process_main_args "${cmd_args[@]}"
                    local exit_code=$?
                    echo
                    read -p "Press Enter to continue..."
                fi
                ;;
            2)
                show_vpn_menu
                ;;
            3)
                if [[ $EUID -ne 0 ]]; then
                    echo -e "${RED}Error: Uninstall requires root privileges.${NC}"
                    read -p "Press Enter to continue..."
                else
                    echo -e "${YELLOW}Are you sure you want to uninstall IPCheck? (y/n) [default: y]: ${NC}"
                    if [[ -c /dev/tty ]] && [[ -r /dev/tty ]]; then
                        exec 3< /dev/tty
                        IFS= read -r confirm <&3
                        exec 3<&-
                    else
                        IFS= read -r confirm
                    fi
                    # Trim whitespace and convert to lowercase
                    confirm=$(echo "$confirm" | tr -d '\n\r' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' | tr '[:upper:]' '[:lower:]')
                    # If empty or y, proceed with uninstall
                    if [[ -z "$confirm" ]] || [[ "$confirm" == "y" ]]; then
                        uninstall_ipcheck
                    fi
                fi
                ;;
            4)
                echo -e "${GREEN}Goodbye! / خداحافظ!${NC}"
                exit 0
                ;;
            "")
                # Empty input, show menu again
                echo -e "\n${YELLOW}⚠️  Please select an option (1-4).${NC}"
                sleep 1
                continue
                ;;
            *)
                echo -e "\n${RED}❌ Invalid option: '${main_choice}'. Please select 1-4.${NC}"
                echo -e "${YELLOW}Press Enter to continue...${NC}"
                local dummy
                if [[ -c /dev/tty ]] && [[ -r /dev/tty ]]; then
                    exec 3< /dev/tty
                    read -r dummy <&3
                    exec 3<&-
                else
                    read -r dummy
                fi
                ;;
        esac
    done
}

process_main_args() {
    # This function contains the main argument processing logic
    # (extracted from main to avoid recursion)
    local ips_to_check=()
    local output_format="table"
    local fail_threshold=1
    local enable_ipqs=false
    local enable_abuseipdb=false
    local enable_scamalytics=false
    local enable_ripe=false
    local enable_host=false
    local enable_hosttracker=false
    local run_all_checks=true
    
    # Pre-process arguments to handle combined flags
    local processed_args=()
    local i=0
    while [[ $i -lt $# ]]; do
        local arg="${!((i+1))}"
        local next_arg="${!((i+2))}"
        
        if [[ "$arg" =~ ^-[a-zA-Z]{2,}$ ]] && [[ ! "$next_arg" =~ ^[0-9]+$ ]]; then
            local flags="${arg#-}"
            for (( j=0; j<${#flags}; j++ )); do
                processed_args+=("-${flags:$j:1}")
            done
        else
            processed_args+=("$arg")
        fi
        ((i++))
    done
    
    set -- "${processed_args[@]}"
    
    # Now process arguments (same as main function)
    while [[ $# -gt 0 ]]; do
        case "$1" in
        -i)
            IFS=',' read -ra ADDR <<<"$2"
            for ip in "${ADDR[@]}"; do ips_to_check+=("$ip"); done
            shift
            ;;
        -f)
            if [[ -f "$2" ]]; then
                mapfile -t FILE_IPS <"$2"
                for ip in "${FILE_IPS[@]}"; do [[ -n "$ip" ]] && ips_to_check+=("$ip"); done
            else
                echo -e "${RED}Error: File not found at '$2'${NC}" >&2
                return 1
            fi
            shift
            ;;
        -S)
            local server_ip
            server_ip=$(get_server_ip)
            if [[ -n "$server_ip" ]]; then 
                ips_to_check+=("$server_ip")
                ASK_VPN_INSTALL=true
            else
                echo -e "${RED}Error: Could not determine server's public IP.${NC}" >&2
                return 1
            fi
            ;;
        -q) enable_ipqs=true; run_all_checks=false ;;
        -a) enable_abuseipdb=true; run_all_checks=false ;;
        -s) enable_scamalytics=true; run_all_checks=false ;;
        -r) enable_ripe=true; run_all_checks=false ;;
        -c) enable_host=true; run_all_checks=false ;;
        -h)
            if [[ $# -eq 1 ]] && [[ ${#ips_to_check[@]} -eq 0 ]]; then
                usage
                return 0
            else
                enable_hosttracker=true
                run_all_checks=false
            fi
            ;;
        -j) output_format="json" ;;
        -o|--output)
            case "$2" in
                json|yaml|csv|xml|table)
                    output_format="$2"
                    ;;
                *)
                    echo -e "${RED}Error: Invalid output format '$2'. Valid formats: json, yaml, csv, xml, table${NC}" >&2
                    return 1
                    ;;
            esac
            shift
            ;;
        -F)
            fail_threshold="$2"
            if ! [[ "$fail_threshold" =~ ^[0-9]+$ ]]; then
                echo -e "${RED}Error: -F requires a number.${NC}"
                return 1
            fi
            shift
            ;;
        -l)
            LOG_DIR="$2"
            if [[ ! -d "$LOG_DIR" ]]; then
                mkdir -p "$LOG_DIR" || {
                    echo -e "${RED}Error: Cannot create log directory '$LOG_DIR'.${NC}" >&2
                    return 1
                }
            fi
            log_message "Logging enabled: $LOG_DIR" "INFO"
            shift
            ;;
        -L)
            LOG_FORMAT="$2"
            if [[ "$LOG_FORMAT" != "txt" ]] && [[ "$LOG_FORMAT" != "json" ]]; then
                echo -e "${RED}Error: -L must be 'txt' or 'json'.${NC}" >&2
                return 1
            fi
            shift
            ;;
        -g) ENABLE_SCORING=true ;;
        -d) ENABLE_CDN_CHECK=true ;;
        -t) ENABLE_ROUTING_CHECK=true ;;
        -p) ENABLE_PORT_SCAN=true ;;
        -R) ENABLE_REALITY_TEST=true ;;
        -u) ENABLE_USAGE_HISTORY=true ;;
        -n) ENABLE_SUGGESTIONS=true ;;
        -v) ASK_VPN_INSTALL=true ;;
        -U) uninstall_ipcheck ;;
        -H|--help)
            usage
            return 0
            ;;
        *)
            echo "Unknown option: $1"
            usage
            return 1
            ;;
        esac
        shift
    done
    
    # Continue with main execution logic
    if [ ${#ips_to_check[@]} -eq 0 ]; then
        echo -e "${RED}Error: No IP addresses to check. Please provide input.${NC}" >&2
        usage
        return 1
    fi
    
    # If no specific checks selected, run all
    if $run_all_checks; then
        enable_ipqs=true
        enable_abuseipdb=true
        enable_scamalytics=true
        enable_ripe=true
        enable_host=true
        enable_hosttracker=true
    fi
    
    load_config
    log_message "Starting IP checks for: ${ips_to_check[*]}" "INFO"
    
    local total_ips=${#ips_to_check[@]}
    local current_ip_num=0
    for ip in "${ips_to_check[@]}"; do
        ((current_ip_num++))
        printf "${BLUE}🔎 [%d/%d] Checking IP: %s${NC}\n" "$current_ip_num" "$total_ips" "$ip"
        local ip_dir="$STATUS_DIR/$(echo "$ip" | tr '.' '_')"
        mkdir -p "$ip_dir"
        
        # Run enabled checks in parallel
        local pids=()
        $enable_ipqs && check_ipqs "$ip" "$ip_dir" & pids+=($!)
        $enable_abuseipdb && check_abuseipdb "$ip" "$ip_dir" & pids+=($!)
        $enable_scamalytics && check_scamalytics "$ip" "$ip_dir" & pids+=($!)
        $enable_ripe && check_ripe "$ip" "$ip_dir" & pids+=($!)
        $enable_host && check_host "$ip" "$ip_dir" & pids+=($!)
        $enable_hosttracker && check_hosttracker "$ip" "$ip_dir" & pids+=($!)
        
        # Additional API checks for scoring
        if $ENABLE_SCORING; then
            check_ipapi "$ip" "$ip_dir" & pids+=($!)
            check_ipregistry "$ip" "$ip_dir" & pids+=($!)
            check_spamhaus "$ip" "$ip_dir" & pids+=($!)
        fi
        
        # Wait for all checks to complete
        for pid in "${pids[@]}"; do
            wait "$pid" || true
        done
        
        # Run advanced features (sequential, as they may depend on previous results)
        if $ENABLE_CDN_CHECK; then
            detect_cdn "$ip" "$ip_dir"
        fi
        
        if $ENABLE_SCORING; then
            generate_score_report "$ip"
            generate_abuse_report "$ip" "$ip_dir"
        fi
        
        # Auto-enable scoring for server check to show score before VPN question
        if [[ "$ip" == "${ips_to_check[0]}" ]] && [[ ${#ips_to_check[@]} -eq 1 ]] && $ASK_VPN_INSTALL; then
            if ! $ENABLE_SCORING; then
                # Run scoring checks if not already enabled
                check_ipapi "$ip" "$ip_dir" & pids_scoring=($!)
                check_ipregistry "$ip" "$ip_dir" & pids_scoring+=($!)
                check_spamhaus "$ip" "$ip_dir" & pids_scoring+=($!)
                for pid in "${pids_scoring[@]}"; do
                    wait "$pid" || true
                done
            fi
            generate_score_report "$ip"
        fi
        
        if $ENABLE_ROUTING_CHECK; then
            test_routing "$ip" "$ip_dir"
        fi
        
        if $ENABLE_PORT_SCAN; then
            scan_ports "$ip" "$ip_dir"
        fi
        
        if $ENABLE_REALITY_TEST; then
            test_reality_fingerprint "$ip" "$ip_dir"
        fi
        
        if $ENABLE_USAGE_HISTORY; then
            check_usage_history "$ip" "$ip_dir"
        fi
        
        if $ENABLE_SUGGESTIONS; then
            generate_suggestions "$ip" "$ip_dir"
        fi
        
        printf "${GREEN}✅ [%d/%d] Done: %s${NC}\n" "$current_ip_num" "$total_ips" "$ip"
    done
    
    echo -e "\n${BLUE}--- Final Report ---${NC}"
    local final_exit_code=0
    local all_passed=true
    
    case "$output_format" in
        json)
            if ! generate_json_report "$(printf "%s\n" "${ips_to_check[@]}")" "$fail_threshold"; then
                final_exit_code=1
                all_passed=false
            fi
            ;;
        yaml)
            if ! generate_yaml_report "$(printf "%s\n" "${ips_to_check[@]}")" "$fail_threshold"; then
                final_exit_code=1
                all_passed=false
            fi
            ;;
        csv)
            if ! generate_csv_report "$(printf "%s\n" "${ips_to_check[@]}")" "$fail_threshold"; then
                final_exit_code=1
                all_passed=false
            fi
            ;;
        xml)
            if ! generate_xml_report "$(printf "%s\n" "${ips_to_check[@]}")" "$fail_threshold"; then
                final_exit_code=1
                all_passed=false
            fi
            ;;
        table|*)
            for ip in "${ips_to_check[@]}"; do
                local ip_dir="$STATUS_DIR/$(echo "$ip" | tr '.' '_')"
                if ! generate_table_report "$ip" "$ip_dir" "$fail_threshold"; then
                    final_exit_code=1
                    all_passed=false
                fi
            done
            ;;
    esac
    
    # Ask for VPN installation if requested and checks passed
    if $ASK_VPN_INSTALL && $all_passed; then
        if [[ ${#ips_to_check[@]} -eq 1 ]]; then
            if [[ -n "$AUTO_VPN_TYPE" ]]; then
                # Auto-install VPN
                auto_install_vpn "${ips_to_check[0]}"
            else
                # Interactive installation
                if [[ -n "$AUTO_VPN_TYPE" ]]; then
                # Auto-install VPN
                auto_install_vpn "${ips_to_check[0]}"
            else
                # Interactive installation
                ask_vpn_installation "${ips_to_check[0]}"
            fi
            fi
        fi
    elif $ASK_VPN_INSTALL && ! $all_passed; then
        echo -e "\n${YELLOW}⚠️  VPN installation skipped: Some checks failed.${NC}"
        log_message "VPN installation skipped: Some checks failed" "WARN"
    fi
    
    # Clean up raw data files (they're already included in JSON output)
    log_message "Cleaning up temporary raw data files" "INFO"
    for ip in "${ips_to_check[@]}"; do
        local ip_dir="$STATUS_DIR/$(echo "$ip" | tr '.' '_')"
        rm -f "$ip_dir"/raw_*.json "$ip_dir"/raw_*.txt 2>/dev/null || true
    done
    
    return $final_exit_code
}

# --- Main Logic ---

usage() {
    echo "Usage: ipcheck [options]"
    echo
    echo "Input Options (at least one is required):"
    echo "  -i <IPs>        Comma-separated list of IP addresses to check."
    echo "  -f <path>       Path to a file containing a list of IPs (one per line)."
    echo "  -S              Automatically check the public IP of this server."
    echo
    echo "Check Selection (if none specified, all available checks run):"
    echo "  -q              Run IPQualityScore check"
    echo "  -a              Run AbuseIPDB check"
    echo "  -s              Run Scamalytics check"
    echo "  -r              Run RIPE Atlas check"
    echo "  -c              Run Check-Host ping test"
    echo "  -h              Run HostTracker check"
    echo
    echo "Advanced Features:"
    echo "  -g              Generate IP Quality Clean Score (0-100)"
    echo "  -d              Detect CDN/proxy presence (Cloudflare, AWS, etc.)"
    echo "  -t              Run routing health analysis (requires mtr/traceroute)"
    echo "  -p              Scan critical ports for risk assessment"
    echo "  -R              Test Sing-box Reality fingerprint compatibility"
    echo "  -u              Check prior usage (VPN/proxy/botnet history)"
    echo "  -n              Generate smart suggestions based on results"
    echo
    echo "Output & Behavior Options:"
    echo "  -j              Output the report in JSON format instead of a table."
    echo "  -F <N>          Exit with error if N or more checks fail (default: 1)."
    echo "  -l <DIR>        Enable logging to specified directory."
    echo "  -L txt|json     Log format: txt or json (default: txt)"
    echo "  -v              Ask to install VPN after server check (interactive)"
    echo
    echo "Other Options:"
    echo "  -U              Uninstall ipcheck (requires root)"
    echo "  -H              Show this help message."
}

# --- VPN Installation Functions ---

install_singbox() {
    log_message "Installing Sing-box" "INFO"
    echo -e "${BLUE}Installing Sing-box...${NC}"
    local install_script
    install_script=$(curl -fsSL https://sing-box.sagernet.org/install.sh || true)
    if [[ -z "$install_script" ]]; then
        echo -e "${RED}Error: Failed to download Sing-box installer.${NC}" >&2
        return 1
    fi
    bash -c "$install_script" || {
        echo -e "${RED}Error: Sing-box installation failed.${NC}" >&2
        return 1
    }
    echo -e "${GREEN}✓ Sing-box installed successfully.${NC}"
    return 0
}

install_xray() {
    log_message "Installing Xray" "INFO"
    echo -e "${BLUE}Installing Xray...${NC}"
    local install_script
    install_script=$(curl -fsSL https://github.com/XTLS/Xray-install/raw/main/install-release.sh || true)
    if [[ -z "$install_script" ]]; then
        echo -e "${RED}Error: Failed to download Xray installer.${NC}" >&2
        return 1
    fi
    bash -c "$install_script" || {
        echo -e "${RED}Error: Xray installation failed.${NC}" >&2
        return 1
    }
    echo -e "${GREEN}✓ Xray installed successfully.${NC}"
    return 0
}

install_v2ray() {
    log_message "Installing V2Ray" "INFO"
    echo -e "${BLUE}Installing V2Ray...${NC}"
    local install_script
    install_script=$(curl -fsSL https://raw.githubusercontent.com/v2fly/fhs-install-v2ray/master/install-release.sh || true)
    if [[ -z "$install_script" ]]; then
        echo -e "${RED}Error: Failed to download V2Ray installer.${NC}" >&2
        return 1
    fi
    bash -c "$install_script" || {
        echo -e "${RED}Error: V2Ray installation failed.${NC}" >&2
        return 1
    }
    echo -e "${GREEN}✓ V2Ray installed successfully.${NC}"
    return 0
}

install_shadowsocks() {
    log_message "Installing Shadowsocks-libev" "INFO"
    echo -e "${BLUE}Installing Shadowsocks-libev...${NC}"
    if command -v apt-get &>/dev/null; then
        apt-get update && apt-get install -y shadowsocks-libev || return 1
    elif command -v yum &>/dev/null; then
        yum install -y epel-release && yum install -y shadowsocks-libev || return 1
    elif command -v dnf &>/dev/null; then
        dnf install -y shadowsocks-libev || return 1
    else
        echo -e "${RED}Error: Unsupported package manager.${NC}" >&2
        return 1
    fi
    echo -e "${GREEN}✓ Shadowsocks-libev installed successfully.${NC}"
    return 0
}

install_openvpn() {
    log_message "Installing OpenVPN" "INFO"
    echo -e "${BLUE}Installing OpenVPN...${NC}"
    if command -v apt-get &>/dev/null; then
        apt-get update && apt-get install -y openvpn easy-rsa || return 1
    elif command -v yum &>/dev/null; then
        yum install -y epel-release && yum install -y openvpn easy-rsa || return 1
    elif command -v dnf &>/dev/null; then
        dnf install -y openvpn easy-rsa || return 1
    else
        echo -e "${RED}Error: Unsupported package manager.${NC}" >&2
        return 1
    fi
    echo -e "${GREEN}✓ OpenVPN installed successfully.${NC}"
    echo -e "${YELLOW}Note: You need to configure OpenVPN manually after installation.${NC}"
    return 0
}

install_cisco() {
    log_message "Installing Cisco AnyConnect (OpenConnect)" "INFO"
    echo -e "${BLUE}Installing OpenConnect (Cisco AnyConnect compatible)...${NC}"
    if command -v apt-get &>/dev/null; then
        apt-get update && apt-get install -y openconnect || return 1
    elif command -v yum &>/dev/null; then
        yum install -y epel-release && yum install -y openconnect || return 1
    elif command -v dnf &>/dev/null; then
        dnf install -y openconnect || return 1
    else
        echo -e "${RED}Error: Unsupported package manager.${NC}" >&2
        return 1
    fi
    echo -e "${GREEN}✓ OpenConnect (Cisco compatible) installed successfully.${NC}"
    echo -e "${YELLOW}Note: OpenConnect is a Cisco AnyConnect compatible client.${NC}"
    return 0
}

# Auto-install VPN without prompting
auto_install_vpn() {
    local ip="$1"
    local vpn_type="${AUTO_VPN_TYPE:-singbox}"  # Default to singbox if not specified
    
    if [[ $EUID -ne 0 ]]; then
        echo -e "${RED}Error: VPN installation requires root privileges.${NC}" >&2
        return 1
    fi
    
    local score=100
    local ip_dir="$STATUS_DIR/$(echo "$ip" | tr '.' '_')"
    if [[ -f "$ip_dir/ip_score.json" ]]; then
        score=$(jq -r '.clean_score // 100' "$ip_dir/ip_score.json" 2>/dev/null || echo "100")
    fi
    
    echo -e "\n${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "${GREEN}✅ IP Check Complete!${NC}"
    echo -e "${BLUE}IP Address: ${YELLOW}$ip${NC}"
    echo -e "${BLUE}Clean Score: ${YELLOW}$score/100${NC}"
    echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}\n"
    
    echo -e "${BLUE}Auto-installing VPN: ${YELLOW}$vpn_type${NC}\n"
    
    case "$vpn_type" in
        singbox|sing-box|1)
            install_singbox
            ;;
        xray|2)
            install_xray
            ;;
        v2ray|3)
            install_v2ray
            ;;
        shadowsocks|shadowsocks-libev|4)
            install_shadowsocks
            ;;
        openvpn|5)
            install_openvpn
            ;;
        cisco|openconnect|6)
            install_cisco
            ;;
        *)
            echo -e "${YELLOW}Unknown VPN type '$vpn_type'. Installing default: Sing-box${NC}"
            install_singbox
            ;;
    esac
}

ask_vpn_installation() {
    local ip="$1"
    local vpn_type="${2:-}"  # Optional VPN type parameter
    
    # If VPN type is provided, use auto-install
    if [[ -n "$vpn_type" ]]; then
        AUTO_VPN_TYPE="$vpn_type"
        auto_install_vpn "$ip"
        return $?
    fi
    
    # Otherwise, ask interactively
    local score=100
    
    # Get score if available
    local ip_dir="$STATUS_DIR/$(echo "$ip" | tr '.' '_')"
    if [[ -f "$ip_dir/ip_score.json" ]]; then
        score=$(jq -r '.clean_score // 100' "$ip_dir/ip_score.json" 2>/dev/null || echo "100")
    fi
    
    echo -e "\n${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "${GREEN}✅ IP Check Complete!${NC}"
    echo -e "${BLUE}IP Address: ${YELLOW}$ip${NC}"
    echo -e "${BLUE}Clean Score: ${YELLOW}$score/100${NC}"
    echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}\n"
    
    if [[ $EUID -ne 0 ]]; then
        echo -e "${YELLOW}Note: VPN installation requires root privileges.${NC}"
        return 0
    fi
    
    echo -e "${BLUE}Would you like to install a VPN server?${NC}"
    echo -e "  1) Sing-box (Recommended for Reality)"
    echo -e "  2) Xray (Xray-core)"
    echo -e "  3) V2Ray (V2Fly)"
    echo -e "  4) Shadowsocks-libev"
    echo -e "  5) OpenVPN"
    echo -e "  6) OpenConnect (Cisco AnyConnect compatible)"
    echo -e "  7) Skip installation"
    echo
    read -p "Select option (1-7): " vpn_choice
    
    case "$vpn_choice" in
        1)
            install_singbox
            ;;
        2)
            install_xray
            ;;
        3)
            install_v2ray
            ;;
        4)
            install_shadowsocks
            ;;
        5)
            install_openvpn
            ;;
        6)
            install_cisco
            ;;
        7)
            echo -e "${YELLOW}Skipping VPN installation.${NC}"
            ;;
        *)
            echo -e "${YELLOW}Invalid option. Skipping installation.${NC}"
            ;;
    esac
}

uninstall_ipcheck() {
    if [[ $EUID -ne 0 ]]; then
        echo -e "${RED}Error: Uninstall requires root privileges. Please run with sudo.${NC}" >&2
        exit 1
    fi
    
    echo -e "${YELLOW}Uninstalling ipcheck...${NC}"
    
    # Remove binary
    if [[ -f "/usr/local/bin/ipcheck" ]]; then
        rm -f "/usr/local/bin/ipcheck"
        echo -e "${GREEN}✓ Removed /usr/local/bin/ipcheck${NC}"
    fi
    
    # Remove man page
    if [[ -f "/usr/share/man/man1/ipcheck.1.gz" ]]; then
        rm -f "/usr/share/man/man1/ipcheck.1.gz"
        mandb -q 2>/dev/null || true
        echo -e "${GREEN}✓ Removed man page${NC}"
    fi
    
    echo -e "${GREEN}✅ Uninstallation complete.${NC}"
    echo -e "${YELLOW}Note: Configuration file (~/.config/ipcheck/keys.conf) was not removed to preserve your API keys.${NC}"
    exit 0
}

parse_combined_flags() {
    local flag_string="$1"
    local -a parsed_flags=()
    
    # Parse combined flags like "gdt" into individual flags
    for (( i=0; i<${#flag_string}; i++ )); do
        local char="${flag_string:$i:1}"
        parsed_flags+=("-$char")
    done
    
    echo "${parsed_flags[@]}"
}

main() {
    # If no arguments, show interactive menu
    if [[ $# -eq 0 ]]; then
        interactive_menu
        exit 0
    fi
    
    # Pre-process arguments to handle combined flags like -gdt
    local processed_args=()
    local i=1
    while [[ $i -le $# ]]; do
        local arg="${!i}"
        local next_arg=""
        if [[ $i -lt $# ]]; then
            next_arg="${!((i+1))}"
        fi
        
        # Check if it's a combined flag (starts with - and has multiple letters, not followed by a number)
        if [[ "$arg" =~ ^-[a-zA-Z]{2,}$ ]] && [[ ! "$next_arg" =~ ^[0-9]+$ ]] && [[ "$arg" != "-"*[0-9]* ]]; then
            # Split combined flags: -gdt -> -g -d -t
            local flags="${arg#-}"
            for (( j=0; j<${#flags}; j++ )); do
                processed_args+=("-${flags:$j:1}")
            done
        else
            processed_args+=("$arg")
        fi
        ((i++))
    done
    
    # Call process_main_args with processed arguments
    process_main_args "${processed_args[@]}"
    exit $?

    # Check for uninstall first
    for arg in "$@"; do
        if [[ "$arg" == "-U" ]] || [[ "$arg" == "--uninstall" ]]; then
            uninstall_ipcheck
        fi
    done
    
    # Check for help
    for arg in "$@"; do
        if [[ "$arg" == "-H" ]] || [[ "$arg" == "--help" ]] || [[ "$arg" == "-h" ]] && [[ ! " ${processed_args[*]} " =~ " -h " ]]; then
        usage
            exit 0
    fi
    done

    while [[ $# -gt 0 ]]; do
        case "$1" in
        -i)
            IFS=',' read -ra ADDR <<<"$2"
            for ip in "${ADDR[@]}"; do ips_to_check+=("$ip"); done
            shift
            ;;
        -f)
            if [[ -f "$2" ]]; then
                mapfile -t FILE_IPS <"$2"
                for ip in "${FILE_IPS[@]}"; do [[ -n "$ip" ]] && ips_to_check+=("$ip"); done
            else
                echo -e "${RED}Error: File not found at '$2'${NC}" >&2
                exit 1
            fi
            shift
            ;;
        -S)
            local server_ip
            server_ip=$(get_server_ip)
            if [[ -n "$server_ip" ]]; then 
                ips_to_check+=("$server_ip")
                ASK_VPN_INSTALL=true  # Auto-enable VPN question for server check
            else
                echo -e "${RED}Error: Could not determine server's public IP.${NC}" >&2
                exit 1
            fi
            ;;
        -q) enable_ipqs=true; run_all_checks=false ;;
        -a) enable_abuseipdb=true; run_all_checks=false ;;
        -s) enable_scamalytics=true; run_all_checks=false ;;
        -r) enable_ripe=true; run_all_checks=false ;;
        -c) enable_host=true; run_all_checks=false ;;
        -h)
            # Check if it's help or hosttracker (help takes precedence if it's the only flag)
            if [[ $# -eq 1 ]] && [[ -z "$ips_to_check" ]]; then
                usage
                exit 0
            else
                enable_hosttracker=true
                run_all_checks=false
            fi
            ;;
        -j) output_format="json" ;;
        -F)
            fail_threshold="$2"
            if ! [[ "$fail_threshold" =~ ^[0-9]+$ ]]; then
                echo -e "${RED}Error: -F requires a number.${NC}"
                exit 1
            fi
            shift
            ;;
        -l)
            LOG_DIR="$2"
            if [[ ! -d "$LOG_DIR" ]]; then
                mkdir -p "$LOG_DIR" || {
                    echo -e "${RED}Error: Cannot create log directory '$LOG_DIR'.${NC}" >&2
                    exit 1
                }
            fi
            log_message "Logging enabled: $LOG_DIR" "INFO"
            shift
            ;;
        -L)
            LOG_FORMAT="$2"
            if [[ "$LOG_FORMAT" != "txt" ]] && [[ "$LOG_FORMAT" != "json" ]]; then
                echo -e "${RED}Error: -L must be 'txt' or 'json'.${NC}" >&2
                exit 1
            fi
            shift
            ;;
        -g) ENABLE_SCORING=true ;;
        -d) ENABLE_CDN_CHECK=true ;;
        -t) ENABLE_ROUTING_CHECK=true ;;
        -p) ENABLE_PORT_SCAN=true ;;
        -R) ENABLE_REALITY_TEST=true ;;
        -u) ENABLE_USAGE_HISTORY=true ;;
        -n) ENABLE_SUGGESTIONS=true ;;
        -v) ASK_VPN_INSTALL=true ;;
        -A|--all)
            # Enable all checks and all advanced features
            enable_ipqs=true
            enable_abuseipdb=true
            enable_scamalytics=true
            enable_ripe=true
            enable_host=true
            enable_hosttracker=true
            ENABLE_SCORING=true
            ENABLE_CDN_CHECK=true
            ENABLE_ROUTING_CHECK=true
            ENABLE_PORT_SCAN=true
            ENABLE_REALITY_TEST=true
            ENABLE_USAGE_HISTORY=true
            ENABLE_SUGGESTIONS=true
            run_all_checks=false
            ;;
        -y)
            ASK_VPN_INSTALL=true
            AUTO_VPN_TYPE="${2:-singbox}"  # Default to singbox if not specified
            shift
            ;;
        --ally)
            # Enable all checks and auto-install VPN
            enable_ipqs=true
            enable_abuseipdb=true
            enable_scamalytics=true
            enable_ripe=true
            enable_host=true
            enable_hosttracker=true
            ENABLE_SCORING=true
            ENABLE_CDN_CHECK=true
            ENABLE_ROUTING_CHECK=true
            ENABLE_PORT_SCAN=true
            ENABLE_REALITY_TEST=true
            ENABLE_USAGE_HISTORY=true
            ENABLE_SUGGESTIONS=true
            run_all_checks=false
            ASK_VPN_INSTALL=true
            # Check if next argument is a VPN type (not a flag)
            if [[ $# -gt 1 ]] && [[ ! "$2" =~ ^- ]]; then
                AUTO_VPN_TYPE="$2"
                shift
            else
                AUTO_VPN_TYPE="singbox"  # Default
            fi
            ;;
        -U) uninstall_ipcheck ;;
        -H|--help)
            usage
            exit 0
            ;;
        # Handle combined flags that might have been missed
        -[a-zA-Z]{2,})
            # This shouldn't happen after preprocessing, but handle it anyway
            local flags="${1#-}"
            for (( i=0; i<${#flags}; i++ )); do
                local flag_char="${flags:$i:1}"
                case "$flag_char" in
                    q) enable_ipqs=true; run_all_checks=false ;;
                    a) enable_abuseipdb=true; run_all_checks=false ;;
                    s) enable_scamalytics=true; run_all_checks=false ;;
                    r) enable_ripe=true; run_all_checks=false ;;
                    c) enable_host=true; run_all_checks=false ;;
                    h) enable_hosttracker=true; run_all_checks=false ;;
                    g) ENABLE_SCORING=true ;;
                    d) ENABLE_CDN_CHECK=true ;;
                    t) ENABLE_ROUTING_CHECK=true ;;
                    p) ENABLE_PORT_SCAN=true ;;
                    R) ENABLE_REALITY_TEST=true ;;
                    u) ENABLE_USAGE_HISTORY=true ;;
                    n) ENABLE_SUGGESTIONS=true ;;
                    j) output_format="json" ;;
                    v) ASK_VPN_INSTALL=true ;;
                esac
            done
            ;;
        # Backward compatibility with old flags
        --file)
            if [[ -f "$2" ]]; then
                mapfile -t FILE_IPS <"$2"
                for ip in "${FILE_IPS[@]}"; do [[ -n "$ip" ]] && ips_to_check+=("$ip"); done
            else
                echo -e "${RED}Error: File not found at '$2'${NC}" >&2
                exit 1
            fi
            shift
            ;;
        --server)
            local server_ip
            server_ip=$(get_server_ip)
            if [[ -n "$server_ip" ]]; then 
                ips_to_check+=("$server_ip")
                ASK_VPN_INSTALL=true
            else
                echo -e "${RED}Error: Could not determine server's public IP.${NC}" >&2
                exit 1
            fi
            ;;
        --json) output_format="json" ;;
        --fail-if)
            fail_threshold="$2"
            if ! [[ "$fail_threshold" =~ ^[0-9]+$ ]]; then
                echo -e "${RED}Error: --fail-if requires a number.${NC}"
                exit 1
            fi
            shift
            ;;
        --log-format)
            LOG_FORMAT="$2"
            if [[ "$LOG_FORMAT" != "txt" ]] && [[ "$LOG_FORMAT" != "json" ]]; then
                echo -e "${RED}Error: --log-format must be 'txt' or 'json'.${NC}" >&2
                exit 1
            fi
            shift
            ;;
        --score) ENABLE_SCORING=true ;;
        --cdn) ENABLE_CDN_CHECK=true ;;
        --routing) ENABLE_ROUTING_CHECK=true ;;
        --port-scan) ENABLE_PORT_SCAN=true ;;
        --reality) ENABLE_REALITY_TEST=true ;;
        --usage-history) ENABLE_USAGE_HISTORY=true ;;
        --suggestions) ENABLE_SUGGESTIONS=true ;;
        --uninstall) uninstall_ipcheck ;;
        *)
            echo "Unknown option: $1"
            usage
            exit 1
            ;;
        esac
        shift
    done

    if [ ${#ips_to_check[@]} -eq 0 ]; then
        echo -e "${RED}Error: No IP addresses to check. Please provide input.${NC}" >&2
        usage
        exit 1
    fi

    # If no specific checks selected, run all
    if $run_all_checks; then
        enable_ipqs=true
        enable_abuseipdb=true
        enable_scamalytics=true
        enable_ripe=true
        enable_host=true
        enable_hosttracker=true
    fi

    load_config
    log_message "Starting IP checks for: ${ips_to_check[*]}"

    local total_ips=${#ips_to_check[@]}
    local current_ip_num=0
    for ip in "${ips_to_check[@]}"; do
        ((current_ip_num++))
        printf "${BLUE}🔎 [%d/%d] Checking IP: %s${NC}\n" "$current_ip_num" "$total_ips" "$ip"
        local ip_dir="$STATUS_DIR/$(echo "$ip" | tr '.' '_')"
        mkdir -p "$ip_dir"
        
        # Run enabled checks in parallel
        local pids=()
        $enable_ipqs && check_ipqs "$ip" "$ip_dir" & pids+=($!)
        $enable_abuseipdb && check_abuseipdb "$ip" "$ip_dir" & pids+=($!)
        $enable_scamalytics && check_scamalytics "$ip" "$ip_dir" & pids+=($!)
        $enable_ripe && check_ripe "$ip" "$ip_dir" & pids+=($!)
        $enable_host && check_host "$ip" "$ip_dir" & pids+=($!)
        $enable_hosttracker && check_hosttracker "$ip" "$ip_dir" & pids+=($!)
        
        # Additional API checks for scoring
        if $ENABLE_SCORING; then
            check_ipapi "$ip" "$ip_dir" & pids+=($!)
            check_ipregistry "$ip" "$ip_dir" & pids+=($!)
            check_spamhaus "$ip" "$ip_dir" & pids+=($!)
        fi
        
        # Wait for all checks to complete
        for pid in "${pids[@]}"; do
            wait "$pid" || true
        done
        
        # Run advanced features (sequential, as they may depend on previous results)
        if $ENABLE_CDN_CHECK; then
            detect_cdn "$ip" "$ip_dir"
        fi
        
        if $ENABLE_SCORING; then
            generate_score_report "$ip"
            generate_abuse_report "$ip" "$ip_dir"
        fi
        
        # Auto-enable scoring for server check to show score before VPN question
        if [[ "$ip" == "${ips_to_check[0]}" ]] && [[ ${#ips_to_check[@]} -eq 1 ]] && $ASK_VPN_INSTALL; then
            if ! $ENABLE_SCORING; then
                # Run scoring checks if not already enabled
                check_ipapi "$ip" "$ip_dir" & pids_scoring=($!)
                check_ipregistry "$ip" "$ip_dir" & pids_scoring+=($!)
                check_spamhaus "$ip" "$ip_dir" & pids_scoring+=($!)
                for pid in "${pids_scoring[@]}"; do
                    wait "$pid" || true
                done
            fi
            generate_score_report "$ip"
        fi
        
        if $ENABLE_ROUTING_CHECK; then
            test_routing "$ip" "$ip_dir"
        fi
        
        if $ENABLE_PORT_SCAN; then
            scan_ports "$ip" "$ip_dir"
        fi
        
        if $ENABLE_REALITY_TEST; then
            test_reality_fingerprint "$ip" "$ip_dir"
        fi
        
        if $ENABLE_USAGE_HISTORY; then
            check_usage_history "$ip" "$ip_dir"
        fi
        
        if $ENABLE_SUGGESTIONS; then
            generate_suggestions "$ip" "$ip_dir"
        fi
        
        printf "${GREEN}✅ [%d/%d] Done: %s${NC}\n" "$current_ip_num" "$total_ips" "$ip"
    done

    echo -e "\n${BLUE}--- Final Report ---${NC}"
    local final_exit_code=0
    local all_passed=true
    
    case "$output_format" in
        json)
            if ! generate_json_report "$(printf "%s\n" "${ips_to_check[@]}")" "$fail_threshold"; then
                final_exit_code=1
                all_passed=false
            fi
            ;;
        yaml)
            if ! generate_yaml_report "$(printf "%s\n" "${ips_to_check[@]}")" "$fail_threshold"; then
                final_exit_code=1
                all_passed=false
            fi
            ;;
        csv)
            if ! generate_csv_report "$(printf "%s\n" "${ips_to_check[@]}")" "$fail_threshold"; then
                final_exit_code=1
                all_passed=false
            fi
            ;;
        xml)
            if ! generate_xml_report "$(printf "%s\n" "${ips_to_check[@]}")" "$fail_threshold"; then
                final_exit_code=1
                all_passed=false
            fi
            ;;
        table|*)
        for ip in "${ips_to_check[@]}"; do
            local ip_dir="$STATUS_DIR/$(echo "$ip" | tr '.' '_')"
            if ! generate_table_report "$ip" "$ip_dir" "$fail_threshold"; then
                    final_exit_code=1
                    all_passed=false
            fi
        done
            ;;
    esac

    # Ask for VPN installation if requested and checks passed
    if $ASK_VPN_INSTALL && $all_passed; then
        # If only one IP was checked (server IP), ask for VPN installation
        if [[ ${#ips_to_check[@]} -eq 1 ]]; then
            if [[ -n "$AUTO_VPN_TYPE" ]]; then
                # Auto-install VPN
                auto_install_vpn "${ips_to_check[0]}"
            else
                # Interactive installation
                ask_vpn_installation "${ips_to_check[0]}"
            fi
        fi
    elif $ASK_VPN_INSTALL && ! $all_passed; then
        echo -e "\n${YELLOW}⚠️  VPN installation skipped: Some checks failed.${NC}"
        log_message "VPN installation skipped: Some checks failed" "WARN"
    fi

    exit "$final_exit_code"
}

main "$@"
